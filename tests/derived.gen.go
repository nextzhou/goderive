// Code generated by https://github.com/nextzhou/goderive. DO NOT EDIT.

package tests

import (
	"encoding/json"
	"fmt"
	"net/http"
	"reflect"
	"sort"
	t "time"

	"github.com/nextzhou/goderive/plugin"
)

func (a *AA) getB() *b {
	if a == nil {
		var defaultVal *b
		return defaultVal
	}
	return a.b
}

func (a *AA) GetB() *b {
	if a == nil {
		var defaultVal *b
		return defaultVal
	}
	return a.B
}

func (a *AA) getC() *c {
	if a == nil {
		var defaultVal *c
		return defaultVal
	}
	return a.c
}

func (a *AA) GetC() *c {
	if a == nil {
		var defaultVal *c
		return defaultVal
	}
	return a.C
}

type IntSet struct {
	elements map[int]struct{}
}

func NewIntSet(capacity int) *IntSet {
	set := new(IntSet)
	if capacity > 0 {
		set.elements = make(map[int]struct{}, capacity)
	} else {
		set.elements = make(map[int]struct{})
	}
	return set
}

func NewIntSetFromSlice(items []int) *IntSet {
	set := NewIntSet(len(items))
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func (set *IntSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *IntSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *IntSet) ToSlice() []int {
	if set == nil {
		return nil
	}
	s := make([]int, 0, set.Len())
	set.ForEach(func(item int) {
		s = append(s, item)
	})
	return s
}

func (set *IntSet) Append(keys ...int) {
	for _, key := range keys {
		set.elements[key] = struct{}{}
	}
}

func (set *IntSet) Clear() {
	set.elements = make(map[int]struct{})
}

func (set *IntSet) Clone() *IntSet {
	cloned := NewIntSet(set.Len())
	for item := range set.elements {
		cloned.elements[item] = struct{}{}
	}
	return cloned
}

func (set *IntSet) Difference(another *IntSet) *IntSet {
	difference := NewIntSet(0)
	set.ForEach(func(item int) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *IntSet) Equal(another *IntSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *IntSet) Intersect(another *IntSet) *IntSet {
	intersection := NewIntSet(0)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *IntSet) Union(another *IntSet) *IntSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *IntSet) InPlaceUnion(another *IntSet) {
	another.ForEach(func(item int) {
		set.Append(item)
	})
}

func (set *IntSet) IsProperSubsetOf(another *IntSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *IntSet) IsProperSupersetOf(another *IntSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *IntSet) IsSubsetOf(another *IntSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *IntSet) IsSupersetOf(another *IntSet) bool {
	return another.IsSubsetOf(set)
}

func (set *IntSet) ForEach(f func(int)) {
	if set.IsEmpty() {
		return
	}
	for item := range set.elements {
		f(item)
	}
}

func (set *IntSet) Filter(f func(int) bool) *IntSet {
	result := NewIntSet(0)
	set.ForEach(func(item int) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *IntSet) Remove(key int) {
	delete(set.elements, key)
}

func (set *IntSet) Contains(key int) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *IntSet) ContainsAny(keys ...int) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *IntSet) ContainsAll(keys ...int) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *IntSet) DoUntilError(f func(int) error) error {
	for item := range set.elements {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *IntSet) All(f func(int) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *IntSet) Any(f func(int) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *IntSet) FindBy(f func(int) bool) *int {
	for item := range set.elements {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *IntSet) CountBy(f func(int) bool) int {
	count := 0
	set.ForEach(func(item int) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *IntSet) GroupByBool(f func(int) bool) (trueGroup *IntSet, falseGroup *IntSet) {
	trueGroup, falseGroup = NewIntSet(0), NewIntSet(0)
	set.ForEach(func(item int) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *IntSet) GroupByStr(f func(int) string) map[string]*IntSet {
	groups := make(map[string]*IntSet)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewIntSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *IntSet) GroupByInt(f func(int) int) map[int]*IntSet {
	groups := make(map[int]*IntSet)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewIntSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *IntSet) GroupBy(f func(int) interface{}) map[interface{}]*IntSet {
	groups := make(map[interface{}]*IntSet)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewIntSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

// f: func(int) T
// return: []T
func (set *IntSet) Map(f interface{}) interface{} {
	expected := "f should be func(int)T"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	elemType := reflect.TypeOf(new(int)).Elem()
	if ft.In(0) != elemType {
		panic(expected)
	}
	if ft.NumOut() != 1 {
		panic(expected)
	}
	outType := ft.Out(0)
	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item int) {
		result = reflect.Append(result, fVal.Call([]reflect.Value{reflect.ValueOf(item)})[0])
	})
	return result.Interface()
}

// f: func(int) *T
//    func(int) (T, bool)
//    func(int) (T, error)
// return: []T
func (set *IntSet) FilterMap(f interface{}) interface{} {
	expected := "f should be func(int) *T / func(int) (T, bool) / func(int) (T, error)"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	in := ft.In(0)
	if in != reflect.TypeOf(new(int)).Elem() {
		panic(expected)
	}
	var outType reflect.Type
	var filter func([]reflect.Value) *reflect.Value
	if ft.NumOut() == 1 {
		// func(int) *T
		outType = ft.Out(0)
		if outType.Kind() != reflect.Ptr {
			panic(expected)
		}
		outType = outType.Elem()
		filter = func(values []reflect.Value) *reflect.Value {
			if values[0].IsNil() {
				return nil
			}
			val := values[0].Elem()
			return &val
		}
	} else if ft.NumOut() == 2 {
		outType = ft.Out(0)
		checker := ft.Out(1)
		if checker == reflect.TypeOf(true) {
			// func(int) (T, bool)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].Interface().(bool) {
					return &values[0]
				}
				return nil
			}
		} else if checker.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
			// func(int) (T, error)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].IsNil() {
					return &values[0]
				}
				return nil
			}
		} else {
			panic(expected)
		}
	} else {
		panic(expected)
	}

	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item int) {
		ret := fVal.Call([]reflect.Value{reflect.ValueOf(item)})
		if val := filter(ret); val != nil {
			result = reflect.Append(result, *val)
		}
	})
	return result.Interface()
}

func (set *IntSet) Reduce(f func(int, int) int) int {
	if set.IsEmpty() {
		var defaultVal int
		return defaultVal
	}
	var ret int
	first := true
	for item := range set.elements {
		if first {
			ret = item
			first = false
			continue
		}
		ret = f(ret, item)
	}
	return ret
}

func (set *IntSet) Fold(init int, f func(int, int) int) int {
	if set.IsEmpty() {
		return init
	}
	for item := range set.elements {
		init = f(init, item)
	}
	return init
}

func (set *IntSet) String() string {
	return fmt.Sprint(set.ToSlice())
}

func (set IntSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *IntSet) UnmarshalJSON(b []byte) error {
	s := make([]int, 0)
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*set = *NewIntSetFromSlice(s)
	return nil
}

type IntSlice struct {
	elements []int
}

func NewIntSlice(capacity int) *IntSlice {
	return &IntSlice{
		elements: make([]int, 0, capacity),
	}
}

func NewIntSliceFromSlice(slice []int) *IntSlice {
	return &IntSlice{
		elements: slice,
	}
}

func (s *IntSlice) Len() int {
	if s == nil {
		return 0
	}
	return len(s.elements)
}

func (s *IntSlice) IsEmpty() bool {
	return s.Len() == 0
}

func (s *IntSlice) Append(items ...int) {
	s.elements = append(s.elements, items...)
}

func (s *IntSlice) Clone() *IntSlice {
	cloned := &IntSlice{
		elements: make([]int, s.Len()),
	}
	copy(cloned.elements, s.elements)
	return cloned
}

func (s *IntSlice) ToSlice() []int {
	slice := make([]int, s.Len())
	copy(slice, s.elements)
	return slice
}

func (s *IntSlice) ToSliceRef() []int {
	return s.elements
}

func (s *IntSlice) Clear() {
	s.elements = s.elements[:0]
}

func (s *IntSlice) Equal(another *IntSlice) bool {
	if s.Len() != another.Len() {
		return false
	}
	for idx, item := range s.elements {
		if item != another.elements[idx] {
			return false
		}
	}
	return false
}

func (s *IntSlice) Insert(idx int, items ...int) {
	if idx < 0 {
		idx += s.Len()
	}
	if l := len(s.elements) + len(items); l > cap(s.elements) {
		// reallocate
		result := make([]int, l)
		copy(result, s.elements[:idx])
		copy(result[idx:], items)
		copy(result[idx+len(items):], s.elements[idx:])
		s.elements = result
		return
	}

	l := s.Len()
	s.elements = append(s.elements, items...)
	copy(s.elements[idx+len(items):], s.elements[idx:l])
	copy(s.elements[idx:], items)
}

func (s *IntSlice) Remove(idx int) {
	if idx < 0 {
		idx += s.Len()
	}
	s.elements = append(s.elements[:idx], s.elements[idx+1:]...)
}

func (s *IntSlice) RemoveRange(from, to int) {
	if from < 0 {
		from += s.Len()
	}
	if to < 0 {
		to += s.Len()
	}
	s.elements = append(s.elements[:from], s.elements[to+1:]...)
}

func (s *IntSlice) RemoveFrom(idx int) {
	if idx < 0 {
		idx += s.Len()
	}
	s.elements = s.elements[:idx]
}

func (s *IntSlice) RemoveTo(idx int) {
	if idx < 0 {
		idx += s.Len()
	}
	s.elements = s.elements[idx+1:]
}

func (s *IntSlice) Concat(another *IntSlice) *IntSlice {
	result := s.Clone()
	if another.IsEmpty() {
		return result
	}
	result.Append(another.elements...)
	return result
}

func (s *IntSlice) InPlaceConcat(another *IntSlice) {
	if another.IsEmpty() {
		return
	}
	s.Append(another.elements...)
}

func (s *IntSlice) ForEach(f func(int)) {
	if s.IsEmpty() {
		return
	}
	for _, item := range s.elements {
		f(item)
	}
}

func (s *IntSlice) ForEachWithIndex(f func(int, int)) {
	if s.IsEmpty() {
		return
	}
	for idx, item := range s.elements {
		f(idx, item)
	}
}

func (s *IntSlice) Filter(f func(int) bool) *IntSlice {
	result := NewIntSlice(0)
	for _, item := range s.elements {
		if f(item) {
			result.Append(item)
		}
	}
	return result
}

func (s *IntSlice) Index(idx int) *int {
	if idx < 0 {
		idx += s.Len()
	}
	return &s.elements[idx]
}

func (s *IntSlice) IndexRange(from, to int) *IntSlice {
	if from < 0 {
		from += s.Len()
	}
	if to < 0 {
		to += s.Len()
	}
	return NewIntSliceFromSlice(s.elements[from:to])
}

func (s *IntSlice) IndexFrom(idx int) *IntSlice {
	if idx < 0 {
		idx += s.Len()
	}
	return NewIntSliceFromSlice(s.elements[idx:])
}

func (s *IntSlice) IndexTo(idx int) *IntSlice {
	if idx < 0 {
		idx += s.Len()
	}
	return NewIntSliceFromSlice(s.elements[:idx])
}

func (s *IntSlice) Find(item int) int {
	if s.IsEmpty() {
		return -1
	}
	for idx, n := range s.elements {
		if n == item {
			return idx
		}
	}
	return -1
}

func (s *IntSlice) FindLast(item int) int {
	for idx := s.Len() - 1; idx >= 0; idx-- {
		if s.elements[idx] == item {
			return idx
		}
	}
	return -1
}

func (s *IntSlice) FindBy(f func(int) bool) int {
	if s.IsEmpty() {
		return -1
	}
	for idx, n := range s.elements {
		if f(n) {
			return idx
		}
	}
	return -1
}

func (s *IntSlice) FindLastBy(f func(int) bool) int {
	for idx := s.Len() - 1; idx >= 0; idx-- {
		if f(s.elements[idx]) {
			return idx
		}
	}
	return -1
}

func (s *IntSlice) Count(item int) uint {
	count := uint(0)
	s.ForEach(func(n int) {
		if n == item {
			count++
		}
	})
	return count
}

func (s *IntSlice) CountBy(f func(int) bool) uint {
	count := uint(0)
	s.ForEach(func(item int) {
		if f(item) {
			count++
		}
	})
	return count
}

func (s *IntSlice) GroupByBool(f func(int) bool) (trueGroup, falseGroup *IntSlice) {
	trueGroup, falseGroup = NewIntSlice(0), NewIntSlice(0)
	s.ForEach(func(item int) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (s IntSlice) GroupByStr(f func(int) string) map[string]*IntSlice {
	groups := make(map[string]*IntSlice)
	s.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewIntSlice(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (s IntSlice) GroupByInt(f func(int) int) map[int]*IntSlice {
	groups := make(map[int]*IntSlice)
	s.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewIntSlice(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (s *IntSlice) GroupBy(f func(int) interface{}) map[interface{}]*IntSlice {
	groups := make(map[interface{}]*IntSlice)
	s.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewIntSlice(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

// f: func(int) T
// return: []T
func (s *IntSlice) Map(f interface{}) interface{} {
	expected := "f should be func(int)T"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	elemType := reflect.TypeOf(new(int)).Elem()
	if ft.In(0) != elemType {
		panic(expected)
	}
	if ft.NumOut() != 1 {
		panic(expected)
	}
	outType := ft.Out(0)
	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, s.Len())
	s.ForEach(func(item int) {
		result = reflect.Append(result, fVal.Call([]reflect.Value{reflect.ValueOf(item)})[0])
	})
	return result.Interface()
}

// f: func(int) *T
//    func(int) (T, bool)
//    func(int) (T, error)
// return: []T
func (s *IntSlice) FilterMap(f interface{}) interface{} {
	expected := "f should be func(int) *T / func(int) (T, bool) / func(int) (T, error)"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	in := ft.In(0)
	if in != reflect.TypeOf(new(int)).Elem() {
		panic(expected)
	}
	var outType reflect.Type
	var filter func([]reflect.Value) *reflect.Value
	if ft.NumOut() == 1 {
		// func(int) *T
		outType = ft.Out(0)
		if outType.Kind() != reflect.Ptr {
			panic(expected)
		}
		outType = outType.Elem()
		filter = func(values []reflect.Value) *reflect.Value {
			if values[0].IsNil() {
				return nil
			}
			val := values[0].Elem()
			return &val
		}
	} else if ft.NumOut() == 2 {
		outType = ft.Out(0)
		checker := ft.Out(1)
		if checker == reflect.TypeOf(true) {
			// func(int) (T, bool)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].Interface().(bool) {
					return &values[0]
				}
				return nil
			}
		} else if checker.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
			// func(int) (T, error)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].IsNil() {
					return &values[0]
				}
				return nil
			}
		} else {
			panic(expected)
		}
	} else {
		panic(expected)
	}

	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, s.Len())
	s.ForEach(func(item int) {
		ret := fVal.Call([]reflect.Value{reflect.ValueOf(item)})
		if val := filter(ret); val != nil {
			result = reflect.Append(result, *val)
		}
	})
	return result.Interface()
}

func (s *IntSlice) DoUntil(f func(int) bool) int {
	for idx, item := range s.elements {
		if f(item) {
			return idx
		}
	}
	return -1
}

func (s *IntSlice) DoWhile(f func(int) bool) int {
	for idx, item := range s.elements {
		if !f(item) {
			return idx
		}
	}
	return -1
}

func (s *IntSlice) DoUntilError(f func(int) error) error {
	for _, item := range s.elements {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (s *IntSlice) All(f func(int) bool) bool {
	for _, item := range s.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (s *IntSlice) Any(f func(int) bool) bool {
	for _, item := range s.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (s *IntSlice) Reduce(f func(int, int) int) int {
	if s.IsEmpty() {
		var defaultVal int
		return defaultVal
	}
	ret := s.elements[0]
	for _, item := range s.elements[1:] {
		ret = f(ret, item)
	}
	return ret
}

func (s *IntSlice) Fold(init int, f func(int, int) int) int {
	if s.IsEmpty() {
		return init
	}
	for _, item := range s.elements {
		init = f(init, item)
	}
	return init
}

func (s *IntSlice) String() string {
	return fmt.Sprint(s.elements)
}

func (s IntSlice) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.elements)
}

func (s *IntSlice) UnmarshalJSON(b []byte) error {
	return json.Unmarshal(b, &s.elements)
}

type intOrderSet struct {
	elements        map[int]uint32
	elementSequence []int
}

func newIntOrderSet(capacity int) *intOrderSet {
	set := new(intOrderSet)
	if capacity > 0 {
		set.elements = make(map[int]uint32, capacity)
		set.elementSequence = make([]int, 0, capacity)
	} else {
		set.elements = make(map[int]uint32)
	}
	return set
}

func newIntOrderSetFromSlice(items []int) *intOrderSet {
	set := newIntOrderSet(len(items))
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func (set *intOrderSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *intOrderSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *intOrderSet) ToSlice() []int {
	if set == nil {
		return nil
	}
	s := make([]int, set.Len())
	copy(s, set.elementSequence)
	return s
}

// NOTICE: efficient but unsafe
func (set *intOrderSet) ToSliceRef() []int {
	return set.elementSequence
}

func (set *intOrderSet) Append(keys ...int) {
	for _, key := range keys {
		if _, ok := set.elements[key]; !ok {
			set.elements[key] = uint32(len(set.elementSequence))
			set.elementSequence = append(set.elementSequence, key)
		}
	}
}

func (set *intOrderSet) Clear() {
	set.elements = make(map[int]uint32)
	set.elementSequence = set.elementSequence[:0]
}

func (set *intOrderSet) Clone() *intOrderSet {
	cloned := newIntOrderSet(set.Len())
	for idx, item := range set.elementSequence {
		cloned.elements[item] = uint32(idx)
		cloned.elementSequence = append(cloned.elementSequence, item)
	}
	return cloned
}

func (set *intOrderSet) Difference(another *intOrderSet) *intOrderSet {
	difference := newIntOrderSet(0)
	set.ForEach(func(item int) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *intOrderSet) Equal(another *intOrderSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	return set.ContainsAll(another.elementSequence...)
}

// TODO keep order
func (set *intOrderSet) Intersect(another *intOrderSet) *intOrderSet {
	intersection := newIntOrderSet(0)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *intOrderSet) Union(another *intOrderSet) *intOrderSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *intOrderSet) InPlaceUnion(another *intOrderSet) {
	another.ForEach(func(item int) {
		set.Append(item)
	})
}

func (set *intOrderSet) IsProperSubsetOf(another *intOrderSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *intOrderSet) IsProperSupersetOf(another *intOrderSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *intOrderSet) IsSubsetOf(another *intOrderSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *intOrderSet) IsSupersetOf(another *intOrderSet) bool {
	return another.IsSubsetOf(set)
}

func (set *intOrderSet) ForEach(f func(int)) {
	if set.IsEmpty() {
		return
	}
	for _, item := range set.elementSequence {
		f(item)
	}
}

func (set *intOrderSet) ForEachWithIndex(f func(int, int)) {
	if set.IsEmpty() {
		return
	}
	for idx, item := range set.elementSequence {
		f(idx, item)
	}
}

func (set *intOrderSet) Filter(f func(int) bool) *intOrderSet {
	result := newIntOrderSet(0)
	set.ForEach(func(item int) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *intOrderSet) Remove(key int) {
	if idx, ok := set.elements[key]; ok {
		l := set.Len()
		delete(set.elements, key)
		for ; idx < uint32(l-1); idx++ {
			item := set.elementSequence[idx+1]
			set.elementSequence[idx] = item
			set.elements[item] = idx
		}
		set.elementSequence = set.elementSequence[:l-1]
	}
}

func (set *intOrderSet) Contains(key int) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *intOrderSet) ContainsAny(keys ...int) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *intOrderSet) ContainsAll(keys ...int) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *intOrderSet) DoUntil(f func(int) bool) int {
	for idx, item := range set.elementSequence {
		if f(item) {
			return idx
		}
	}
	return -1
}

func (set *intOrderSet) DoWhile(f func(int) bool) int {
	for idx, item := range set.elementSequence {
		if !f(item) {
			return idx
		}
	}
	return -1
}

func (set *intOrderSet) DoUntilError(f func(int) error) error {
	for _, item := range set.elementSequence {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *intOrderSet) All(f func(int) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *intOrderSet) Any(f func(int) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *intOrderSet) FindBy(f func(int) bool) *int {
	for _, item := range set.elementSequence {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *intOrderSet) FindLastBy(f func(int) bool) *int {
	for i := set.Len() - 1; i >= 0; i-- {
		if item := set.elementSequence[i]; f(item) {
			return &item
		}
	}
	return nil
}

func (set *intOrderSet) CountBy(f func(int) bool) int {
	count := 0
	set.ForEach(func(item int) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *intOrderSet) GroupByBool(f func(int) bool) (trueGroup *intOrderSet, falseGroup *intOrderSet) {
	trueGroup, falseGroup = newIntOrderSet(0), newIntOrderSet(0)
	set.ForEach(func(item int) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *intOrderSet) GroupByStr(f func(int) string) map[string]*intOrderSet {
	groups := make(map[string]*intOrderSet)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newIntOrderSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *intOrderSet) GroupByInt(f func(int) int) map[int]*intOrderSet {
	groups := make(map[int]*intOrderSet)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newIntOrderSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *intOrderSet) GroupBy(f func(int) interface{}) map[interface{}]*intOrderSet {
	groups := make(map[interface{}]*intOrderSet)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newIntOrderSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

// f: func(int) T
// return: []T
func (set *intOrderSet) Map(f interface{}) interface{} {
	expected := "f should be func(int)T"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	elemType := reflect.TypeOf(new(int)).Elem()
	if ft.In(0) != elemType {
		panic(expected)
	}
	if ft.NumOut() != 1 {
		panic(expected)
	}
	outType := ft.Out(0)
	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item int) {
		result = reflect.Append(result, fVal.Call([]reflect.Value{reflect.ValueOf(item)})[0])
	})
	return result.Interface()
}

// f: func(int) *T
//    func(int) (T, bool)
//    func(int) (T, error)
// return: []T
func (set *intOrderSet) FilterMap(f interface{}) interface{} {
	expected := "f should be func(int) *T / func(int) (T, bool) / func(int) (T, error)"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	in := ft.In(0)
	if in != reflect.TypeOf(new(int)).Elem() {
		panic(expected)
	}
	var outType reflect.Type
	var filter func([]reflect.Value) *reflect.Value
	if ft.NumOut() == 1 {
		// func(int) *T
		outType = ft.Out(0)
		if outType.Kind() != reflect.Ptr {
			panic(expected)
		}
		outType = outType.Elem()
		filter = func(values []reflect.Value) *reflect.Value {
			if values[0].IsNil() {
				return nil
			}
			val := values[0].Elem()
			return &val
		}
	} else if ft.NumOut() == 2 {
		outType = ft.Out(0)
		checker := ft.Out(1)
		if checker == reflect.TypeOf(true) {
			// func(int) (T, bool)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].Interface().(bool) {
					return &values[0]
				}
				return nil
			}
		} else if checker.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
			// func(int) (T, error)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].IsNil() {
					return &values[0]
				}
				return nil
			}
		} else {
			panic(expected)
		}
	} else {
		panic(expected)
	}

	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item int) {
		ret := fVal.Call([]reflect.Value{reflect.ValueOf(item)})
		if val := filter(ret); val != nil {
			result = reflect.Append(result, *val)
		}
	})
	return result.Interface()
}

func (set *intOrderSet) Reduce(f func(int, int) int) int {
	if set.IsEmpty() {
		var defaultVal int
		return defaultVal
	}
	ret := set.elementSequence[0]
	for _, item := range set.elementSequence[1:] {
		ret = f(ret, item)
	}
	return ret
}

func (set *intOrderSet) Fold(init int, f func(int, int) int) int {
	if set.IsEmpty() {
		return init
	}
	for _, item := range set.elementSequence {
		init = f(init, item)
	}
	return init
}

func (set *intOrderSet) String() string {
	return fmt.Sprint(set.elementSequence)
}

func (set intOrderSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *intOrderSet) UnmarshalJSON(b []byte) error {
	s := make([]int, 0)
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*set = *newIntOrderSetFromSlice(s)
	return nil
}

type Int3Set struct {
	cmp             func(i, j int) bool
	elements        map[int]uint32
	elementSequence []int
}

func NewInt3Set(capacity int, cmp func(i, j int) bool) *Int3Set {
	set := new(Int3Set)
	if capacity > 0 {
		set.elements = make(map[int]uint32, capacity)
		set.elementSequence = make([]int, 0, capacity)
	} else {
		set.elements = make(map[int]uint32)
	}
	set.cmp = cmp
	return set
}

func NewInt3SetFromSlice(items []int, cmp func(i, j int) bool) *Int3Set {
	set := NewInt3Set(len(items), cmp)
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func NewAscendingInt3Set(capacity int) *Int3Set {
	return NewInt3Set(capacity, func(i, j int) bool { return i < j })
}

func NewDescendingInt3Set(capacity int) *Int3Set {
	return NewInt3Set(capacity, func(i, j int) bool { return i > j })
}

func NewAscendingInt3SetFromSlice(items []int) *Int3Set {
	return NewInt3SetFromSlice(items, func(i, j int) bool { return i < j })
}

func NewDescendingInt3SetFromSlice(items []int) *Int3Set {
	return NewInt3SetFromSlice(items, func(i, j int) bool { return i > j })
}

func (set *Int3Set) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *Int3Set) IsEmpty() bool {
	return set.Len() == 0
}

func (set *Int3Set) ToSlice() []int {
	if set == nil {
		return nil
	}
	s := make([]int, set.Len())
	copy(s, set.elementSequence)
	return s
}

// NOTICE: efficient but unsafe
func (set *Int3Set) ToSliceRef() []int {
	return set.elementSequence
}

func (set *Int3Set) Append(keys ...int) {
	for _, key := range keys {
		if _, ok := set.elements[key]; !ok {
			idx := sort.Search(len(set.elementSequence), func(i int) bool {
				return set.cmp(key, set.elementSequence[i])
			})
			l := len(set.elementSequence)
			set.elementSequence = append(set.elementSequence, key)
			for i := l; i > idx; i-- {
				set.elements[set.elementSequence[i]] = uint32(i + 1)
				set.elementSequence[i] = set.elementSequence[i-1]
			}
			set.elements[set.elementSequence[idx]] = uint32(idx + 1)
			set.elementSequence[idx] = key
			set.elements[key] = uint32(idx)
		}
	}
}

func (set *Int3Set) Clear() {
	set.elements = make(map[int]uint32)
	set.elementSequence = set.elementSequence[:0]
}

func (set *Int3Set) Clone() *Int3Set {
	cloned := NewInt3Set(set.Len(), set.cmp)
	for idx, item := range set.elementSequence {
		cloned.elements[item] = uint32(idx)
		cloned.elementSequence = append(cloned.elementSequence, item)
	}
	return cloned
}

func (set *Int3Set) Difference(another *Int3Set) *Int3Set {
	difference := NewInt3Set(0, set.cmp)
	set.ForEach(func(item int) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *Int3Set) Equal(another *Int3Set) bool {
	if set.Len() != another.Len() {
		return false
	}
	return set.ContainsAll(another.elementSequence...)
}

func (set *Int3Set) Intersect(another *Int3Set) *Int3Set {
	intersection := NewInt3Set(0, set.cmp)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *Int3Set) Union(another *Int3Set) *Int3Set {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *Int3Set) InPlaceUnion(another *Int3Set) {
	another.ForEach(func(item int) {
		set.Append(item)
	})
}

func (set *Int3Set) IsProperSubsetOf(another *Int3Set) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *Int3Set) IsProperSupersetOf(another *Int3Set) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *Int3Set) IsSubsetOf(another *Int3Set) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *Int3Set) IsSupersetOf(another *Int3Set) bool {
	return another.IsSubsetOf(set)
}

func (set *Int3Set) ForEach(f func(int)) {
	if set.IsEmpty() {
		return
	}
	for _, item := range set.elementSequence {
		f(item)
	}
}

func (set *Int3Set) ForEachWithIndex(f func(int, int)) {
	if set.IsEmpty() {
		return
	}
	for idx, item := range set.elementSequence {
		f(idx, item)
	}
}

func (set *Int3Set) Filter(f func(int) bool) *Int3Set {
	result := NewInt3Set(0, set.cmp)
	set.ForEach(func(item int) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *Int3Set) Remove(key int) {
	if idx, ok := set.elements[key]; ok {
		l := set.Len()
		delete(set.elements, key)
		for ; idx < uint32(l-1); idx++ {
			item := set.elementSequence[idx+1]
			set.elementSequence[idx] = item
			set.elements[item] = idx
		}
		set.elementSequence = set.elementSequence[:l-1]
	}
}

func (set *Int3Set) Contains(key int) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *Int3Set) ContainsAny(keys ...int) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *Int3Set) ContainsAll(keys ...int) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *Int3Set) DoUntil(f func(int) bool) int {
	for idx, item := range set.elementSequence {
		if f(item) {
			return idx
		}
	}
	return -1
}

func (set *Int3Set) DoWhile(f func(int) bool) int {
	for idx, item := range set.elementSequence {
		if !f(item) {
			return idx
		}
	}
	return -1
}

func (set *Int3Set) DoUntilError(f func(int) error) error {
	for _, item := range set.elementSequence {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *Int3Set) All(f func(int) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *Int3Set) Any(f func(int) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *Int3Set) FindBy(f func(int) bool) *int {
	for _, item := range set.elementSequence {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *Int3Set) FindLastBy(f func(int) bool) *int {
	for i := set.Len() - 1; i >= 0; i-- {
		if item := set.elementSequence[i]; f(item) {
			return &item
		}
	}
	return nil
}

func (set *Int3Set) CountBy(f func(int) bool) int {
	count := 0
	set.ForEach(func(item int) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *Int3Set) GroupByBool(f func(int) bool) (trueGroup *Int3Set, falseGroup *Int3Set) {
	trueGroup, falseGroup = NewInt3Set(0, set.cmp), NewInt3Set(0, set.cmp)
	set.ForEach(func(item int) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *Int3Set) GroupByStr(f func(int) string) map[string]*Int3Set {
	groups := make(map[string]*Int3Set)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewInt3Set(0, set.cmp)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *Int3Set) GroupByInt(f func(int) int) map[int]*Int3Set {
	groups := make(map[int]*Int3Set)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewInt3Set(0, set.cmp)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *Int3Set) GroupBy(f func(int) interface{}) map[interface{}]*Int3Set {
	groups := make(map[interface{}]*Int3Set)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewInt3Set(0, set.cmp)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

// f: func(int) T
// return: []T
func (set *Int3Set) Map(f interface{}) interface{} {
	expected := "f should be func(int)T"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	elemType := reflect.TypeOf(new(int)).Elem()
	if ft.In(0) != elemType {
		panic(expected)
	}
	if ft.NumOut() != 1 {
		panic(expected)
	}
	outType := ft.Out(0)
	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item int) {
		result = reflect.Append(result, fVal.Call([]reflect.Value{reflect.ValueOf(item)})[0])
	})
	return result.Interface()
}

// f: func(int) *T
//    func(int) (T, bool)
//    func(int) (T, error)
// return: []T
func (set *Int3Set) FilterMap(f interface{}) interface{} {
	expected := "f should be func(int) *T / func(int) (T, bool) / func(int) (T, error)"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	in := ft.In(0)
	if in != reflect.TypeOf(new(int)).Elem() {
		panic(expected)
	}
	var outType reflect.Type
	var filter func([]reflect.Value) *reflect.Value
	if ft.NumOut() == 1 {
		// func(int) *T
		outType = ft.Out(0)
		if outType.Kind() != reflect.Ptr {
			panic(expected)
		}
		outType = outType.Elem()
		filter = func(values []reflect.Value) *reflect.Value {
			if values[0].IsNil() {
				return nil
			}
			val := values[0].Elem()
			return &val
		}
	} else if ft.NumOut() == 2 {
		outType = ft.Out(0)
		checker := ft.Out(1)
		if checker == reflect.TypeOf(true) {
			// func(int) (T, bool)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].Interface().(bool) {
					return &values[0]
				}
				return nil
			}
		} else if checker.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
			// func(int) (T, error)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].IsNil() {
					return &values[0]
				}
				return nil
			}
		} else {
			panic(expected)
		}
	} else {
		panic(expected)
	}

	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item int) {
		ret := fVal.Call([]reflect.Value{reflect.ValueOf(item)})
		if val := filter(ret); val != nil {
			result = reflect.Append(result, *val)
		}
	})
	return result.Interface()
}

func (set *Int3Set) Reduce(f func(int, int) int) int {
	if set.IsEmpty() {
		var defaultVal int
		return defaultVal
	}
	ret := set.elementSequence[0]
	for _, item := range set.elementSequence[1:] {
		ret = f(ret, item)
	}
	return ret
}

func (set *Int3Set) Fold(init int, f func(int, int) int) int {
	if set.IsEmpty() {
		return init
	}
	for _, item := range set.elementSequence {
		init = f(init, item)
	}
	return init
}

func (set *Int3Set) String() string {
	return fmt.Sprint(set.elementSequence)
}

func (set Int3Set) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *Int3Set) UnmarshalJSON(b []byte) error {
	return fmt.Errorf("unsupported")
}

type myTypeSet struct {
	elements map[MyType]struct{}
}

func newMyTypeSet(capacity int) *myTypeSet {
	set := new(myTypeSet)
	if capacity > 0 {
		set.elements = make(map[MyType]struct{}, capacity)
	} else {
		set.elements = make(map[MyType]struct{})
	}
	return set
}

func newMyTypeSetFromSlice(items []MyType) *myTypeSet {
	set := newMyTypeSet(len(items))
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func (set *myTypeSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *myTypeSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *myTypeSet) ToSlice() []MyType {
	if set == nil {
		return nil
	}
	s := make([]MyType, 0, set.Len())
	set.ForEach(func(item MyType) {
		s = append(s, item)
	})
	return s
}

func (set *myTypeSet) Append(keys ...MyType) {
	for _, key := range keys {
		set.elements[key] = struct{}{}
	}
}

func (set *myTypeSet) Clear() {
	set.elements = make(map[MyType]struct{})
}

func (set *myTypeSet) Clone() *myTypeSet {
	cloned := newMyTypeSet(set.Len())
	for item := range set.elements {
		cloned.elements[item] = struct{}{}
	}
	return cloned
}

func (set *myTypeSet) Difference(another *myTypeSet) *myTypeSet {
	difference := newMyTypeSet(0)
	set.ForEach(func(item MyType) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *myTypeSet) Equal(another *myTypeSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *myTypeSet) Intersect(another *myTypeSet) *myTypeSet {
	intersection := newMyTypeSet(0)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *myTypeSet) Union(another *myTypeSet) *myTypeSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *myTypeSet) InPlaceUnion(another *myTypeSet) {
	another.ForEach(func(item MyType) {
		set.Append(item)
	})
}

func (set *myTypeSet) IsProperSubsetOf(another *myTypeSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *myTypeSet) IsProperSupersetOf(another *myTypeSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *myTypeSet) IsSubsetOf(another *myTypeSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *myTypeSet) IsSupersetOf(another *myTypeSet) bool {
	return another.IsSubsetOf(set)
}

func (set *myTypeSet) ForEach(f func(MyType)) {
	if set.IsEmpty() {
		return
	}
	for item := range set.elements {
		f(item)
	}
}

func (set *myTypeSet) Filter(f func(MyType) bool) *myTypeSet {
	result := newMyTypeSet(0)
	set.ForEach(func(item MyType) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *myTypeSet) Remove(key MyType) {
	delete(set.elements, key)
}

func (set *myTypeSet) Contains(key MyType) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *myTypeSet) ContainsAny(keys ...MyType) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *myTypeSet) ContainsAll(keys ...MyType) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *myTypeSet) DoUntilError(f func(MyType) error) error {
	for item := range set.elements {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *myTypeSet) All(f func(MyType) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *myTypeSet) Any(f func(MyType) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *myTypeSet) FindBy(f func(MyType) bool) *MyType {
	for item := range set.elements {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *myTypeSet) CountBy(f func(MyType) bool) int {
	count := 0
	set.ForEach(func(item MyType) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *myTypeSet) GroupByBool(f func(MyType) bool) (trueGroup *myTypeSet, falseGroup *myTypeSet) {
	trueGroup, falseGroup = newMyTypeSet(0), newMyTypeSet(0)
	set.ForEach(func(item MyType) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *myTypeSet) GroupByStr(f func(MyType) string) map[string]*myTypeSet {
	groups := make(map[string]*myTypeSet)
	set.ForEach(func(item MyType) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newMyTypeSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *myTypeSet) GroupByInt(f func(MyType) int) map[int]*myTypeSet {
	groups := make(map[int]*myTypeSet)
	set.ForEach(func(item MyType) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newMyTypeSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *myTypeSet) GroupBy(f func(MyType) interface{}) map[interface{}]*myTypeSet {
	groups := make(map[interface{}]*myTypeSet)
	set.ForEach(func(item MyType) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newMyTypeSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

// f: func(MyType) T
// return: []T
func (set *myTypeSet) Map(f interface{}) interface{} {
	expected := "f should be func(MyType)T"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	elemType := reflect.TypeOf(new(MyType)).Elem()
	if ft.In(0) != elemType {
		panic(expected)
	}
	if ft.NumOut() != 1 {
		panic(expected)
	}
	outType := ft.Out(0)
	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item MyType) {
		result = reflect.Append(result, fVal.Call([]reflect.Value{reflect.ValueOf(item)})[0])
	})
	return result.Interface()
}

// f: func(MyType) *T
//    func(MyType) (T, bool)
//    func(MyType) (T, error)
// return: []T
func (set *myTypeSet) FilterMap(f interface{}) interface{} {
	expected := "f should be func(MyType) *T / func(MyType) (T, bool) / func(MyType) (T, error)"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	in := ft.In(0)
	if in != reflect.TypeOf(new(MyType)).Elem() {
		panic(expected)
	}
	var outType reflect.Type
	var filter func([]reflect.Value) *reflect.Value
	if ft.NumOut() == 1 {
		// func(MyType) *T
		outType = ft.Out(0)
		if outType.Kind() != reflect.Ptr {
			panic(expected)
		}
		outType = outType.Elem()
		filter = func(values []reflect.Value) *reflect.Value {
			if values[0].IsNil() {
				return nil
			}
			val := values[0].Elem()
			return &val
		}
	} else if ft.NumOut() == 2 {
		outType = ft.Out(0)
		checker := ft.Out(1)
		if checker == reflect.TypeOf(true) {
			// func(MyType) (T, bool)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].Interface().(bool) {
					return &values[0]
				}
				return nil
			}
		} else if checker.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
			// func(MyType) (T, error)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].IsNil() {
					return &values[0]
				}
				return nil
			}
		} else {
			panic(expected)
		}
	} else {
		panic(expected)
	}

	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item MyType) {
		ret := fVal.Call([]reflect.Value{reflect.ValueOf(item)})
		if val := filter(ret); val != nil {
			result = reflect.Append(result, *val)
		}
	})
	return result.Interface()
}

func (set *myTypeSet) Reduce(f func(MyType, MyType) MyType) MyType {
	if set.IsEmpty() {
		var defaultVal MyType
		return defaultVal
	}
	var ret MyType
	first := true
	for item := range set.elements {
		if first {
			ret = item
			first = false
			continue
		}
		ret = f(ret, item)
	}
	return ret
}

func (set *myTypeSet) Fold(init MyType, f func(MyType, MyType) MyType) MyType {
	if set.IsEmpty() {
		return init
	}
	for item := range set.elements {
		init = f(init, item)
	}
	return init
}

func (set *myTypeSet) String() string {
	return fmt.Sprint(set.ToSlice())
}

func (set myTypeSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *myTypeSet) UnmarshalJSON(b []byte) error {
	s := make([]MyType, 0)
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*set = *newMyTypeSetFromSlice(s)
	return nil
}

type NotComparableTypeSlice struct {
	elements []NotComparableType
}

func NewNotComparableTypeSlice(capacity int) *NotComparableTypeSlice {
	return &NotComparableTypeSlice{
		elements: make([]NotComparableType, 0, capacity),
	}
}

func NewNotComparableTypeSliceFromSlice(slice []NotComparableType) *NotComparableTypeSlice {
	return &NotComparableTypeSlice{
		elements: slice,
	}
}

func (s *NotComparableTypeSlice) Len() int {
	if s == nil {
		return 0
	}
	return len(s.elements)
}

func (s *NotComparableTypeSlice) IsEmpty() bool {
	return s.Len() == 0
}

func (s *NotComparableTypeSlice) Append(items ...NotComparableType) {
	s.elements = append(s.elements, items...)
}

func (s *NotComparableTypeSlice) Clone() *NotComparableTypeSlice {
	cloned := &NotComparableTypeSlice{
		elements: make([]NotComparableType, s.Len()),
	}
	copy(cloned.elements, s.elements)
	return cloned
}

func (s *NotComparableTypeSlice) ToSlice() []NotComparableType {
	slice := make([]NotComparableType, s.Len())
	copy(slice, s.elements)
	return slice
}

func (s *NotComparableTypeSlice) ToSliceRef() []NotComparableType {
	return s.elements
}

func (s *NotComparableTypeSlice) Clear() {
	s.elements = s.elements[:0]
}

func (s *NotComparableTypeSlice) Insert(idx int, items ...NotComparableType) {
	if idx < 0 {
		idx += s.Len()
	}
	if l := len(s.elements) + len(items); l > cap(s.elements) {
		// reallocate
		result := make([]NotComparableType, l)
		copy(result, s.elements[:idx])
		copy(result[idx:], items)
		copy(result[idx+len(items):], s.elements[idx:])
		s.elements = result
		return
	}

	l := s.Len()
	s.elements = append(s.elements, items...)
	copy(s.elements[idx+len(items):], s.elements[idx:l])
	copy(s.elements[idx:], items)
}

func (s *NotComparableTypeSlice) Remove(idx int) {
	if idx < 0 {
		idx += s.Len()
	}
	s.elements = append(s.elements[:idx], s.elements[idx+1:]...)
}

func (s *NotComparableTypeSlice) RemoveRange(from, to int) {
	if from < 0 {
		from += s.Len()
	}
	if to < 0 {
		to += s.Len()
	}
	s.elements = append(s.elements[:from], s.elements[to+1:]...)
}

func (s *NotComparableTypeSlice) RemoveFrom(idx int) {
	if idx < 0 {
		idx += s.Len()
	}
	s.elements = s.elements[:idx]
}

func (s *NotComparableTypeSlice) RemoveTo(idx int) {
	if idx < 0 {
		idx += s.Len()
	}
	s.elements = s.elements[idx+1:]
}

func (s *NotComparableTypeSlice) Concat(another *NotComparableTypeSlice) *NotComparableTypeSlice {
	result := s.Clone()
	if another.IsEmpty() {
		return result
	}
	result.Append(another.elements...)
	return result
}

func (s *NotComparableTypeSlice) InPlaceConcat(another *NotComparableTypeSlice) {
	if another.IsEmpty() {
		return
	}
	s.Append(another.elements...)
}

func (s *NotComparableTypeSlice) ForEach(f func(NotComparableType)) {
	if s.IsEmpty() {
		return
	}
	for _, item := range s.elements {
		f(item)
	}
}

func (s *NotComparableTypeSlice) ForEachWithIndex(f func(int, NotComparableType)) {
	if s.IsEmpty() {
		return
	}
	for idx, item := range s.elements {
		f(idx, item)
	}
}

func (s *NotComparableTypeSlice) Filter(f func(NotComparableType) bool) *NotComparableTypeSlice {
	result := NewNotComparableTypeSlice(0)
	for _, item := range s.elements {
		if f(item) {
			result.Append(item)
		}
	}
	return result
}

func (s *NotComparableTypeSlice) Index(idx int) *NotComparableType {
	if idx < 0 {
		idx += s.Len()
	}
	return &s.elements[idx]
}

func (s *NotComparableTypeSlice) IndexRange(from, to int) *NotComparableTypeSlice {
	if from < 0 {
		from += s.Len()
	}
	if to < 0 {
		to += s.Len()
	}
	return NewNotComparableTypeSliceFromSlice(s.elements[from:to])
}

func (s *NotComparableTypeSlice) IndexFrom(idx int) *NotComparableTypeSlice {
	if idx < 0 {
		idx += s.Len()
	}
	return NewNotComparableTypeSliceFromSlice(s.elements[idx:])
}

func (s *NotComparableTypeSlice) IndexTo(idx int) *NotComparableTypeSlice {
	if idx < 0 {
		idx += s.Len()
	}
	return NewNotComparableTypeSliceFromSlice(s.elements[:idx])
}

func (s *NotComparableTypeSlice) FindBy(f func(NotComparableType) bool) int {
	if s.IsEmpty() {
		return -1
	}
	for idx, n := range s.elements {
		if f(n) {
			return idx
		}
	}
	return -1
}

func (s *NotComparableTypeSlice) FindLastBy(f func(NotComparableType) bool) int {
	for idx := s.Len() - 1; idx >= 0; idx-- {
		if f(s.elements[idx]) {
			return idx
		}
	}
	return -1
}

func (s *NotComparableTypeSlice) CountBy(f func(NotComparableType) bool) uint {
	count := uint(0)
	s.ForEach(func(item NotComparableType) {
		if f(item) {
			count++
		}
	})
	return count
}

func (s *NotComparableTypeSlice) GroupByBool(f func(NotComparableType) bool) (trueGroup, falseGroup *NotComparableTypeSlice) {
	trueGroup, falseGroup = NewNotComparableTypeSlice(0), NewNotComparableTypeSlice(0)
	s.ForEach(func(item NotComparableType) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (s NotComparableTypeSlice) GroupByStr(f func(NotComparableType) string) map[string]*NotComparableTypeSlice {
	groups := make(map[string]*NotComparableTypeSlice)
	s.ForEach(func(item NotComparableType) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewNotComparableTypeSlice(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (s NotComparableTypeSlice) GroupByInt(f func(NotComparableType) int) map[int]*NotComparableTypeSlice {
	groups := make(map[int]*NotComparableTypeSlice)
	s.ForEach(func(item NotComparableType) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewNotComparableTypeSlice(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (s *NotComparableTypeSlice) GroupBy(f func(NotComparableType) interface{}) map[interface{}]*NotComparableTypeSlice {
	groups := make(map[interface{}]*NotComparableTypeSlice)
	s.ForEach(func(item NotComparableType) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewNotComparableTypeSlice(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

// f: func(NotComparableType) T
// return: []T
func (s *NotComparableTypeSlice) Map(f interface{}) interface{} {
	expected := "f should be func(NotComparableType)T"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	elemType := reflect.TypeOf(new(NotComparableType)).Elem()
	if ft.In(0) != elemType {
		panic(expected)
	}
	if ft.NumOut() != 1 {
		panic(expected)
	}
	outType := ft.Out(0)
	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, s.Len())
	s.ForEach(func(item NotComparableType) {
		result = reflect.Append(result, fVal.Call([]reflect.Value{reflect.ValueOf(item)})[0])
	})
	return result.Interface()
}

// f: func(NotComparableType) *T
//    func(NotComparableType) (T, bool)
//    func(NotComparableType) (T, error)
// return: []T
func (s *NotComparableTypeSlice) FilterMap(f interface{}) interface{} {
	expected := "f should be func(NotComparableType) *T / func(NotComparableType) (T, bool) / func(NotComparableType) (T, error)"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	in := ft.In(0)
	if in != reflect.TypeOf(new(NotComparableType)).Elem() {
		panic(expected)
	}
	var outType reflect.Type
	var filter func([]reflect.Value) *reflect.Value
	if ft.NumOut() == 1 {
		// func(NotComparableType) *T
		outType = ft.Out(0)
		if outType.Kind() != reflect.Ptr {
			panic(expected)
		}
		outType = outType.Elem()
		filter = func(values []reflect.Value) *reflect.Value {
			if values[0].IsNil() {
				return nil
			}
			val := values[0].Elem()
			return &val
		}
	} else if ft.NumOut() == 2 {
		outType = ft.Out(0)
		checker := ft.Out(1)
		if checker == reflect.TypeOf(true) {
			// func(NotComparableType) (T, bool)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].Interface().(bool) {
					return &values[0]
				}
				return nil
			}
		} else if checker.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
			// func(NotComparableType) (T, error)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].IsNil() {
					return &values[0]
				}
				return nil
			}
		} else {
			panic(expected)
		}
	} else {
		panic(expected)
	}

	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, s.Len())
	s.ForEach(func(item NotComparableType) {
		ret := fVal.Call([]reflect.Value{reflect.ValueOf(item)})
		if val := filter(ret); val != nil {
			result = reflect.Append(result, *val)
		}
	})
	return result.Interface()
}

func (s *NotComparableTypeSlice) DoUntil(f func(NotComparableType) bool) int {
	for idx, item := range s.elements {
		if f(item) {
			return idx
		}
	}
	return -1
}

func (s *NotComparableTypeSlice) DoWhile(f func(NotComparableType) bool) int {
	for idx, item := range s.elements {
		if !f(item) {
			return idx
		}
	}
	return -1
}

func (s *NotComparableTypeSlice) DoUntilError(f func(NotComparableType) error) error {
	for _, item := range s.elements {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (s *NotComparableTypeSlice) All(f func(NotComparableType) bool) bool {
	for _, item := range s.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (s *NotComparableTypeSlice) Any(f func(NotComparableType) bool) bool {
	for _, item := range s.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (s *NotComparableTypeSlice) Reduce(f func(NotComparableType, NotComparableType) NotComparableType) NotComparableType {
	if s.IsEmpty() {
		var defaultVal NotComparableType
		return defaultVal
	}
	ret := s.elements[0]
	for _, item := range s.elements[1:] {
		ret = f(ret, item)
	}
	return ret
}

func (s *NotComparableTypeSlice) Fold(init NotComparableType, f func(NotComparableType, NotComparableType) NotComparableType) NotComparableType {
	if s.IsEmpty() {
		return init
	}
	for _, item := range s.elements {
		init = f(init, item)
	}
	return init
}

func (s *NotComparableTypeSlice) String() string {
	return fmt.Sprint(s.elements)
}

func (s NotComparableTypeSlice) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.elements)
}

func (s *NotComparableTypeSlice) UnmarshalJSON(b []byte) error {
	return json.Unmarshal(b, &s.elements)
}

type SSet struct {
	cmp             func(i, j string) bool
	elements        map[string]uint32
	elementSequence []string
}

func NewSSet(capacity int, cmp func(i, j string) bool) *SSet {
	set := new(SSet)
	if capacity > 0 {
		set.elements = make(map[string]uint32, capacity)
		set.elementSequence = make([]string, 0, capacity)
	} else {
		set.elements = make(map[string]uint32)
	}
	set.cmp = cmp
	return set
}

func NewSSetFromSlice(items []string, cmp func(i, j string) bool) *SSet {
	set := NewSSet(len(items), cmp)
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func NewAscendingSSet(capacity int) *SSet {
	return NewSSet(capacity, func(i, j string) bool { return i < j })
}

func NewDescendingSSet(capacity int) *SSet {
	return NewSSet(capacity, func(i, j string) bool { return i > j })
}

func NewAscendingSSetFromSlice(items []string) *SSet {
	return NewSSetFromSlice(items, func(i, j string) bool { return i < j })
}

func NewDescendingSSetFromSlice(items []string) *SSet {
	return NewSSetFromSlice(items, func(i, j string) bool { return i > j })
}

func (set *SSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *SSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *SSet) ToSlice() []string {
	if set == nil {
		return nil
	}
	s := make([]string, set.Len())
	copy(s, set.elementSequence)
	return s
}

// NOTICE: efficient but unsafe
func (set *SSet) ToSliceRef() []string {
	return set.elementSequence
}

func (set *SSet) Append(keys ...string) {
	for _, key := range keys {
		if _, ok := set.elements[key]; !ok {
			idx := sort.Search(len(set.elementSequence), func(i int) bool {
				return set.cmp(key, set.elementSequence[i])
			})
			l := len(set.elementSequence)
			set.elementSequence = append(set.elementSequence, key)
			for i := l; i > idx; i-- {
				set.elements[set.elementSequence[i]] = uint32(i + 1)
				set.elementSequence[i] = set.elementSequence[i-1]
			}
			set.elements[set.elementSequence[idx]] = uint32(idx + 1)
			set.elementSequence[idx] = key
			set.elements[key] = uint32(idx)
		}
	}
}

func (set *SSet) Clear() {
	set.elements = make(map[string]uint32)
	set.elementSequence = set.elementSequence[:0]
}

func (set *SSet) Clone() *SSet {
	cloned := NewSSet(set.Len(), set.cmp)
	for idx, item := range set.elementSequence {
		cloned.elements[item] = uint32(idx)
		cloned.elementSequence = append(cloned.elementSequence, item)
	}
	return cloned
}

func (set *SSet) Difference(another *SSet) *SSet {
	difference := NewSSet(0, set.cmp)
	set.ForEach(func(item string) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *SSet) Equal(another *SSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	return set.ContainsAll(another.elementSequence...)
}

func (set *SSet) Intersect(another *SSet) *SSet {
	intersection := NewSSet(0, set.cmp)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *SSet) Union(another *SSet) *SSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *SSet) InPlaceUnion(another *SSet) {
	another.ForEach(func(item string) {
		set.Append(item)
	})
}

func (set *SSet) IsProperSubsetOf(another *SSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *SSet) IsProperSupersetOf(another *SSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *SSet) IsSubsetOf(another *SSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *SSet) IsSupersetOf(another *SSet) bool {
	return another.IsSubsetOf(set)
}

func (set *SSet) ForEach(f func(string)) {
	if set.IsEmpty() {
		return
	}
	for _, item := range set.elementSequence {
		f(item)
	}
}

func (set *SSet) ForEachWithIndex(f func(int, string)) {
	if set.IsEmpty() {
		return
	}
	for idx, item := range set.elementSequence {
		f(idx, item)
	}
}

func (set *SSet) Filter(f func(string) bool) *SSet {
	result := NewSSet(0, set.cmp)
	set.ForEach(func(item string) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *SSet) Remove(key string) {
	if idx, ok := set.elements[key]; ok {
		l := set.Len()
		delete(set.elements, key)
		for ; idx < uint32(l-1); idx++ {
			item := set.elementSequence[idx+1]
			set.elementSequence[idx] = item
			set.elements[item] = idx
		}
		set.elementSequence = set.elementSequence[:l-1]
	}
}

func (set *SSet) Contains(key string) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *SSet) ContainsAny(keys ...string) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *SSet) ContainsAll(keys ...string) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *SSet) DoUntil(f func(string) bool) int {
	for idx, item := range set.elementSequence {
		if f(item) {
			return idx
		}
	}
	return -1
}

func (set *SSet) DoWhile(f func(string) bool) int {
	for idx, item := range set.elementSequence {
		if !f(item) {
			return idx
		}
	}
	return -1
}

func (set *SSet) DoUntilError(f func(string) error) error {
	for _, item := range set.elementSequence {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *SSet) All(f func(string) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *SSet) Any(f func(string) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *SSet) FindBy(f func(string) bool) *string {
	for _, item := range set.elementSequence {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *SSet) FindLastBy(f func(string) bool) *string {
	for i := set.Len() - 1; i >= 0; i-- {
		if item := set.elementSequence[i]; f(item) {
			return &item
		}
	}
	return nil
}

func (set *SSet) CountBy(f func(string) bool) int {
	count := 0
	set.ForEach(func(item string) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *SSet) GroupByBool(f func(string) bool) (trueGroup *SSet, falseGroup *SSet) {
	trueGroup, falseGroup = NewSSet(0, set.cmp), NewSSet(0, set.cmp)
	set.ForEach(func(item string) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *SSet) GroupByStr(f func(string) string) map[string]*SSet {
	groups := make(map[string]*SSet)
	set.ForEach(func(item string) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewSSet(0, set.cmp)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *SSet) GroupByInt(f func(string) int) map[int]*SSet {
	groups := make(map[int]*SSet)
	set.ForEach(func(item string) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewSSet(0, set.cmp)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *SSet) GroupBy(f func(string) interface{}) map[interface{}]*SSet {
	groups := make(map[interface{}]*SSet)
	set.ForEach(func(item string) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewSSet(0, set.cmp)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

// f: func(string) T
// return: []T
func (set *SSet) Map(f interface{}) interface{} {
	expected := "f should be func(string)T"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	elemType := reflect.TypeOf(new(string)).Elem()
	if ft.In(0) != elemType {
		panic(expected)
	}
	if ft.NumOut() != 1 {
		panic(expected)
	}
	outType := ft.Out(0)
	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item string) {
		result = reflect.Append(result, fVal.Call([]reflect.Value{reflect.ValueOf(item)})[0])
	})
	return result.Interface()
}

// f: func(string) *T
//    func(string) (T, bool)
//    func(string) (T, error)
// return: []T
func (set *SSet) FilterMap(f interface{}) interface{} {
	expected := "f should be func(string) *T / func(string) (T, bool) / func(string) (T, error)"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	in := ft.In(0)
	if in != reflect.TypeOf(new(string)).Elem() {
		panic(expected)
	}
	var outType reflect.Type
	var filter func([]reflect.Value) *reflect.Value
	if ft.NumOut() == 1 {
		// func(string) *T
		outType = ft.Out(0)
		if outType.Kind() != reflect.Ptr {
			panic(expected)
		}
		outType = outType.Elem()
		filter = func(values []reflect.Value) *reflect.Value {
			if values[0].IsNil() {
				return nil
			}
			val := values[0].Elem()
			return &val
		}
	} else if ft.NumOut() == 2 {
		outType = ft.Out(0)
		checker := ft.Out(1)
		if checker == reflect.TypeOf(true) {
			// func(string) (T, bool)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].Interface().(bool) {
					return &values[0]
				}
				return nil
			}
		} else if checker.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
			// func(string) (T, error)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].IsNil() {
					return &values[0]
				}
				return nil
			}
		} else {
			panic(expected)
		}
	} else {
		panic(expected)
	}

	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item string) {
		ret := fVal.Call([]reflect.Value{reflect.ValueOf(item)})
		if val := filter(ret); val != nil {
			result = reflect.Append(result, *val)
		}
	})
	return result.Interface()
}

func (set *SSet) Reduce(f func(string, string) string) string {
	if set.IsEmpty() {
		var defaultVal string
		return defaultVal
	}
	ret := set.elementSequence[0]
	for _, item := range set.elementSequence[1:] {
		ret = f(ret, item)
	}
	return ret
}

func (set *SSet) Fold(init string, f func(string, string) string) string {
	if set.IsEmpty() {
		return init
	}
	for _, item := range set.elementSequence {
		init = f(init, item)
	}
	return init
}

func (set *SSet) String() string {
	return fmt.Sprint(set.elementSequence)
}

func (set SSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *SSet) UnmarshalJSON(b []byte) error {
	return fmt.Errorf("unsupported")
}

type TSet struct {
	elements map[t.Time]struct{}
}

func NewTSet(capacity int) *TSet {
	set := new(TSet)
	if capacity > 0 {
		set.elements = make(map[t.Time]struct{}, capacity)
	} else {
		set.elements = make(map[t.Time]struct{})
	}
	return set
}

func NewTSetFromSlice(items []t.Time) *TSet {
	set := NewTSet(len(items))
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func (set *TSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *TSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *TSet) ToSlice() []t.Time {
	if set == nil {
		return nil
	}
	s := make([]t.Time, 0, set.Len())
	set.ForEach(func(item t.Time) {
		s = append(s, item)
	})
	return s
}

func (set *TSet) Append(keys ...t.Time) {
	for _, key := range keys {
		set.elements[key] = struct{}{}
	}
}

func (set *TSet) Clear() {
	set.elements = make(map[t.Time]struct{})
}

func (set *TSet) Clone() *TSet {
	cloned := NewTSet(set.Len())
	for item := range set.elements {
		cloned.elements[item] = struct{}{}
	}
	return cloned
}

func (set *TSet) Difference(another *TSet) *TSet {
	difference := NewTSet(0)
	set.ForEach(func(item t.Time) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *TSet) Equal(another *TSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *TSet) Intersect(another *TSet) *TSet {
	intersection := NewTSet(0)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *TSet) Union(another *TSet) *TSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *TSet) InPlaceUnion(another *TSet) {
	another.ForEach(func(item t.Time) {
		set.Append(item)
	})
}

func (set *TSet) IsProperSubsetOf(another *TSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *TSet) IsProperSupersetOf(another *TSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *TSet) IsSubsetOf(another *TSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *TSet) IsSupersetOf(another *TSet) bool {
	return another.IsSubsetOf(set)
}

func (set *TSet) ForEach(f func(t.Time)) {
	if set.IsEmpty() {
		return
	}
	for item := range set.elements {
		f(item)
	}
}

func (set *TSet) Filter(f func(t.Time) bool) *TSet {
	result := NewTSet(0)
	set.ForEach(func(item t.Time) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *TSet) Remove(key t.Time) {
	delete(set.elements, key)
}

func (set *TSet) Contains(key t.Time) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *TSet) ContainsAny(keys ...t.Time) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *TSet) ContainsAll(keys ...t.Time) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *TSet) DoUntilError(f func(t.Time) error) error {
	for item := range set.elements {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *TSet) All(f func(t.Time) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *TSet) Any(f func(t.Time) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *TSet) FindBy(f func(t.Time) bool) *t.Time {
	for item := range set.elements {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *TSet) CountBy(f func(t.Time) bool) int {
	count := 0
	set.ForEach(func(item t.Time) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *TSet) GroupByBool(f func(t.Time) bool) (trueGroup *TSet, falseGroup *TSet) {
	trueGroup, falseGroup = NewTSet(0), NewTSet(0)
	set.ForEach(func(item t.Time) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *TSet) GroupByStr(f func(t.Time) string) map[string]*TSet {
	groups := make(map[string]*TSet)
	set.ForEach(func(item t.Time) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewTSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *TSet) GroupByInt(f func(t.Time) int) map[int]*TSet {
	groups := make(map[int]*TSet)
	set.ForEach(func(item t.Time) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewTSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *TSet) GroupBy(f func(t.Time) interface{}) map[interface{}]*TSet {
	groups := make(map[interface{}]*TSet)
	set.ForEach(func(item t.Time) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewTSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

// f: func(t.Time) T
// return: []T
func (set *TSet) Map(f interface{}) interface{} {
	expected := "f should be func(t.Time)T"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	elemType := reflect.TypeOf(new(t.Time)).Elem()
	if ft.In(0) != elemType {
		panic(expected)
	}
	if ft.NumOut() != 1 {
		panic(expected)
	}
	outType := ft.Out(0)
	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item t.Time) {
		result = reflect.Append(result, fVal.Call([]reflect.Value{reflect.ValueOf(item)})[0])
	})
	return result.Interface()
}

// f: func(t.Time) *T
//    func(t.Time) (T, bool)
//    func(t.Time) (T, error)
// return: []T
func (set *TSet) FilterMap(f interface{}) interface{} {
	expected := "f should be func(t.Time) *T / func(t.Time) (T, bool) / func(t.Time) (T, error)"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	in := ft.In(0)
	if in != reflect.TypeOf(new(t.Time)).Elem() {
		panic(expected)
	}
	var outType reflect.Type
	var filter func([]reflect.Value) *reflect.Value
	if ft.NumOut() == 1 {
		// func(t.Time) *T
		outType = ft.Out(0)
		if outType.Kind() != reflect.Ptr {
			panic(expected)
		}
		outType = outType.Elem()
		filter = func(values []reflect.Value) *reflect.Value {
			if values[0].IsNil() {
				return nil
			}
			val := values[0].Elem()
			return &val
		}
	} else if ft.NumOut() == 2 {
		outType = ft.Out(0)
		checker := ft.Out(1)
		if checker == reflect.TypeOf(true) {
			// func(t.Time) (T, bool)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].Interface().(bool) {
					return &values[0]
				}
				return nil
			}
		} else if checker.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
			// func(t.Time) (T, error)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].IsNil() {
					return &values[0]
				}
				return nil
			}
		} else {
			panic(expected)
		}
	} else {
		panic(expected)
	}

	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item t.Time) {
		ret := fVal.Call([]reflect.Value{reflect.ValueOf(item)})
		if val := filter(ret); val != nil {
			result = reflect.Append(result, *val)
		}
	})
	return result.Interface()
}

func (set *TSet) Reduce(f func(t.Time, t.Time) t.Time) t.Time {
	if set.IsEmpty() {
		var defaultVal t.Time
		return defaultVal
	}
	var ret t.Time
	first := true
	for item := range set.elements {
		if first {
			ret = item
			first = false
			continue
		}
		ret = f(ret, item)
	}
	return ret
}

func (set *TSet) Fold(init t.Time, f func(t.Time, t.Time) t.Time) t.Time {
	if set.IsEmpty() {
		return init
	}
	for item := range set.elements {
		init = f(init, item)
	}
	return init
}

func (set *TSet) String() string {
	return fmt.Sprint(set.ToSlice())
}

func (set TSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *TSet) UnmarshalJSON(b []byte) error {
	s := make([]t.Time, 0)
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*set = *NewTSetFromSlice(s)
	return nil
}

func (b *b) getC() *c {
	if b == nil {
		var defaultVal *c
		return defaultVal
	}
	return b.c
}

func (b *b) GetC() *c {
	if b == nil {
		var defaultVal *c
		return defaultVal
	}
	return b.C
}

func (c *c) getAbc() string {
	if c == nil {
		var defaultVal string
		return defaultVal
	}
	return c.abc
}

func (c *c) GetDef() *int {
	if c == nil {
		var defaultVal *int
		return defaultVal
	}
	return c.Def
}

func (c *c) getA() t.Time {
	if c == nil {
		var defaultVal t.Time
		return defaultVal
	}
	return c.a
}

func (c *c) getB() []string {
	if c == nil {
		var defaultVal []string
		return defaultVal
	}
	return c.b
}

func (c *c) getBb() [3]string {
	if c == nil {
		var defaultVal [3]string
		return defaultVal
	}
	return c.bb
}

func (c *c) getC() map[int]string {
	if c == nil {
		var defaultVal map[int]string
		return defaultVal
	}
	return c.c
}

func (c *c) getD() chan int {
	if c == nil {
		var defaultVal chan int
		return defaultVal
	}
	return c.d
}

func (c *c) getE() chan<- int {
	if c == nil {
		var defaultVal chan<- int
		return defaultVal
	}
	return c.e
}

func (c *c) getF() <-chan int {
	if c == nil {
		var defaultVal <-chan int
		return defaultVal
	}
	return c.f
}

func (c *c) getFf() func(int, string, c, d t.Time) (a, b bool, e error) {
	if c == nil {
		var defaultVal func(int, string, c, d t.Time) (a, b bool, e error)
		return defaultVal
	}
	return c.ff
}

type hSet struct {
	elements map[http.Handler]struct{}
}

func newHSet(capacity int) *hSet {
	set := new(hSet)
	if capacity > 0 {
		set.elements = make(map[http.Handler]struct{}, capacity)
	} else {
		set.elements = make(map[http.Handler]struct{})
	}
	return set
}

func newHSetFromSlice(items []http.Handler) *hSet {
	set := newHSet(len(items))
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func (set *hSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *hSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *hSet) ToSlice() []http.Handler {
	if set == nil {
		return nil
	}
	s := make([]http.Handler, 0, set.Len())
	set.ForEach(func(item http.Handler) {
		s = append(s, item)
	})
	return s
}

func (set *hSet) Append(keys ...http.Handler) {
	for _, key := range keys {
		set.elements[key] = struct{}{}
	}
}

func (set *hSet) Clear() {
	set.elements = make(map[http.Handler]struct{})
}

func (set *hSet) Clone() *hSet {
	cloned := newHSet(set.Len())
	for item := range set.elements {
		cloned.elements[item] = struct{}{}
	}
	return cloned
}

func (set *hSet) Difference(another *hSet) *hSet {
	difference := newHSet(0)
	set.ForEach(func(item http.Handler) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *hSet) Equal(another *hSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *hSet) Intersect(another *hSet) *hSet {
	intersection := newHSet(0)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *hSet) Union(another *hSet) *hSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *hSet) InPlaceUnion(another *hSet) {
	another.ForEach(func(item http.Handler) {
		set.Append(item)
	})
}

func (set *hSet) IsProperSubsetOf(another *hSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *hSet) IsProperSupersetOf(another *hSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *hSet) IsSubsetOf(another *hSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *hSet) IsSupersetOf(another *hSet) bool {
	return another.IsSubsetOf(set)
}

func (set *hSet) ForEach(f func(http.Handler)) {
	if set.IsEmpty() {
		return
	}
	for item := range set.elements {
		f(item)
	}
}

func (set *hSet) Filter(f func(http.Handler) bool) *hSet {
	result := newHSet(0)
	set.ForEach(func(item http.Handler) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *hSet) Remove(key http.Handler) {
	delete(set.elements, key)
}

func (set *hSet) Contains(key http.Handler) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *hSet) ContainsAny(keys ...http.Handler) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *hSet) ContainsAll(keys ...http.Handler) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *hSet) DoUntilError(f func(http.Handler) error) error {
	for item := range set.elements {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *hSet) All(f func(http.Handler) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *hSet) Any(f func(http.Handler) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *hSet) FindBy(f func(http.Handler) bool) *http.Handler {
	for item := range set.elements {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *hSet) CountBy(f func(http.Handler) bool) int {
	count := 0
	set.ForEach(func(item http.Handler) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *hSet) GroupByBool(f func(http.Handler) bool) (trueGroup *hSet, falseGroup *hSet) {
	trueGroup, falseGroup = newHSet(0), newHSet(0)
	set.ForEach(func(item http.Handler) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *hSet) GroupByStr(f func(http.Handler) string) map[string]*hSet {
	groups := make(map[string]*hSet)
	set.ForEach(func(item http.Handler) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newHSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *hSet) GroupByInt(f func(http.Handler) int) map[int]*hSet {
	groups := make(map[int]*hSet)
	set.ForEach(func(item http.Handler) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newHSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *hSet) GroupBy(f func(http.Handler) interface{}) map[interface{}]*hSet {
	groups := make(map[interface{}]*hSet)
	set.ForEach(func(item http.Handler) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newHSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

// f: func(http.Handler) T
// return: []T
func (set *hSet) Map(f interface{}) interface{} {
	expected := "f should be func(http.Handler)T"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	elemType := reflect.TypeOf(new(http.Handler)).Elem()
	if ft.In(0) != elemType {
		panic(expected)
	}
	if ft.NumOut() != 1 {
		panic(expected)
	}
	outType := ft.Out(0)
	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item http.Handler) {
		result = reflect.Append(result, fVal.Call([]reflect.Value{reflect.ValueOf(item)})[0])
	})
	return result.Interface()
}

// f: func(http.Handler) *T
//    func(http.Handler) (T, bool)
//    func(http.Handler) (T, error)
// return: []T
func (set *hSet) FilterMap(f interface{}) interface{} {
	expected := "f should be func(http.Handler) *T / func(http.Handler) (T, bool) / func(http.Handler) (T, error)"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	in := ft.In(0)
	if in != reflect.TypeOf(new(http.Handler)).Elem() {
		panic(expected)
	}
	var outType reflect.Type
	var filter func([]reflect.Value) *reflect.Value
	if ft.NumOut() == 1 {
		// func(http.Handler) *T
		outType = ft.Out(0)
		if outType.Kind() != reflect.Ptr {
			panic(expected)
		}
		outType = outType.Elem()
		filter = func(values []reflect.Value) *reflect.Value {
			if values[0].IsNil() {
				return nil
			}
			val := values[0].Elem()
			return &val
		}
	} else if ft.NumOut() == 2 {
		outType = ft.Out(0)
		checker := ft.Out(1)
		if checker == reflect.TypeOf(true) {
			// func(http.Handler) (T, bool)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].Interface().(bool) {
					return &values[0]
				}
				return nil
			}
		} else if checker.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
			// func(http.Handler) (T, error)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].IsNil() {
					return &values[0]
				}
				return nil
			}
		} else {
			panic(expected)
		}
	} else {
		panic(expected)
	}

	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item http.Handler) {
		ret := fVal.Call([]reflect.Value{reflect.ValueOf(item)})
		if val := filter(ret); val != nil {
			result = reflect.Append(result, *val)
		}
	})
	return result.Interface()
}

func (set *hSet) Reduce(f func(http.Handler, http.Handler) http.Handler) http.Handler {
	if set.IsEmpty() {
		var defaultVal http.Handler
		return defaultVal
	}
	var ret http.Handler
	first := true
	for item := range set.elements {
		if first {
			ret = item
			first = false
			continue
		}
		ret = f(ret, item)
	}
	return ret
}

func (set *hSet) Fold(init http.Handler, f func(http.Handler, http.Handler) http.Handler) http.Handler {
	if set.IsEmpty() {
		return init
	}
	for item := range set.elements {
		init = f(init, item)
	}
	return init
}

func (set *hSet) String() string {
	return fmt.Sprint(set.ToSlice())
}

func (set hSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *hSet) UnmarshalJSON(b []byte) error {
	s := make([]http.Handler, 0)
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*set = *newHSetFromSlice(s)
	return nil
}

type hSlice struct {
	elements []http.Handler
}

func newHSlice(capacity int) *hSlice {
	return &hSlice{
		elements: make([]http.Handler, 0, capacity),
	}
}

func newHSliceFromSlice(slice []http.Handler) *hSlice {
	return &hSlice{
		elements: slice,
	}
}

func (s *hSlice) Len() int {
	if s == nil {
		return 0
	}
	return len(s.elements)
}

func (s *hSlice) IsEmpty() bool {
	return s.Len() == 0
}

func (s *hSlice) Append(items ...http.Handler) {
	s.elements = append(s.elements, items...)
}

func (s *hSlice) Clone() *hSlice {
	cloned := &hSlice{
		elements: make([]http.Handler, s.Len()),
	}
	copy(cloned.elements, s.elements)
	return cloned
}

func (s *hSlice) ToSlice() []http.Handler {
	slice := make([]http.Handler, s.Len())
	copy(slice, s.elements)
	return slice
}

func (s *hSlice) ToSliceRef() []http.Handler {
	return s.elements
}

func (s *hSlice) Clear() {
	s.elements = s.elements[:0]
}

func (s *hSlice) Insert(idx int, items ...http.Handler) {
	if idx < 0 {
		idx += s.Len()
	}
	if l := len(s.elements) + len(items); l > cap(s.elements) {
		// reallocate
		result := make([]http.Handler, l)
		copy(result, s.elements[:idx])
		copy(result[idx:], items)
		copy(result[idx+len(items):], s.elements[idx:])
		s.elements = result
		return
	}

	l := s.Len()
	s.elements = append(s.elements, items...)
	copy(s.elements[idx+len(items):], s.elements[idx:l])
	copy(s.elements[idx:], items)
}

func (s *hSlice) Remove(idx int) {
	if idx < 0 {
		idx += s.Len()
	}
	s.elements = append(s.elements[:idx], s.elements[idx+1:]...)
}

func (s *hSlice) RemoveRange(from, to int) {
	if from < 0 {
		from += s.Len()
	}
	if to < 0 {
		to += s.Len()
	}
	s.elements = append(s.elements[:from], s.elements[to+1:]...)
}

func (s *hSlice) RemoveFrom(idx int) {
	if idx < 0 {
		idx += s.Len()
	}
	s.elements = s.elements[:idx]
}

func (s *hSlice) RemoveTo(idx int) {
	if idx < 0 {
		idx += s.Len()
	}
	s.elements = s.elements[idx+1:]
}

func (s *hSlice) Concat(another *hSlice) *hSlice {
	result := s.Clone()
	if another.IsEmpty() {
		return result
	}
	result.Append(another.elements...)
	return result
}

func (s *hSlice) InPlaceConcat(another *hSlice) {
	if another.IsEmpty() {
		return
	}
	s.Append(another.elements...)
}

func (s *hSlice) ForEach(f func(http.Handler)) {
	if s.IsEmpty() {
		return
	}
	for _, item := range s.elements {
		f(item)
	}
}

func (s *hSlice) ForEachWithIndex(f func(int, http.Handler)) {
	if s.IsEmpty() {
		return
	}
	for idx, item := range s.elements {
		f(idx, item)
	}
}

func (s *hSlice) Filter(f func(http.Handler) bool) *hSlice {
	result := newHSlice(0)
	for _, item := range s.elements {
		if f(item) {
			result.Append(item)
		}
	}
	return result
}

func (s *hSlice) Index(idx int) *http.Handler {
	if idx < 0 {
		idx += s.Len()
	}
	return &s.elements[idx]
}

func (s *hSlice) IndexRange(from, to int) *hSlice {
	if from < 0 {
		from += s.Len()
	}
	if to < 0 {
		to += s.Len()
	}
	return newHSliceFromSlice(s.elements[from:to])
}

func (s *hSlice) IndexFrom(idx int) *hSlice {
	if idx < 0 {
		idx += s.Len()
	}
	return newHSliceFromSlice(s.elements[idx:])
}

func (s *hSlice) IndexTo(idx int) *hSlice {
	if idx < 0 {
		idx += s.Len()
	}
	return newHSliceFromSlice(s.elements[:idx])
}

func (s *hSlice) FindBy(f func(http.Handler) bool) int {
	if s.IsEmpty() {
		return -1
	}
	for idx, n := range s.elements {
		if f(n) {
			return idx
		}
	}
	return -1
}

func (s *hSlice) FindLastBy(f func(http.Handler) bool) int {
	for idx := s.Len() - 1; idx >= 0; idx-- {
		if f(s.elements[idx]) {
			return idx
		}
	}
	return -1
}

func (s *hSlice) CountBy(f func(http.Handler) bool) uint {
	count := uint(0)
	s.ForEach(func(item http.Handler) {
		if f(item) {
			count++
		}
	})
	return count
}

func (s *hSlice) GroupByBool(f func(http.Handler) bool) (trueGroup, falseGroup *hSlice) {
	trueGroup, falseGroup = newHSlice(0), newHSlice(0)
	s.ForEach(func(item http.Handler) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (s hSlice) GroupByStr(f func(http.Handler) string) map[string]*hSlice {
	groups := make(map[string]*hSlice)
	s.ForEach(func(item http.Handler) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newHSlice(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (s hSlice) GroupByInt(f func(http.Handler) int) map[int]*hSlice {
	groups := make(map[int]*hSlice)
	s.ForEach(func(item http.Handler) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newHSlice(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (s *hSlice) GroupBy(f func(http.Handler) interface{}) map[interface{}]*hSlice {
	groups := make(map[interface{}]*hSlice)
	s.ForEach(func(item http.Handler) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newHSlice(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

// f: func(http.Handler) T
// return: []T
func (s *hSlice) Map(f interface{}) interface{} {
	expected := "f should be func(http.Handler)T"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	elemType := reflect.TypeOf(new(http.Handler)).Elem()
	if ft.In(0) != elemType {
		panic(expected)
	}
	if ft.NumOut() != 1 {
		panic(expected)
	}
	outType := ft.Out(0)
	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, s.Len())
	s.ForEach(func(item http.Handler) {
		result = reflect.Append(result, fVal.Call([]reflect.Value{reflect.ValueOf(item)})[0])
	})
	return result.Interface()
}

// f: func(http.Handler) *T
//    func(http.Handler) (T, bool)
//    func(http.Handler) (T, error)
// return: []T
func (s *hSlice) FilterMap(f interface{}) interface{} {
	expected := "f should be func(http.Handler) *T / func(http.Handler) (T, bool) / func(http.Handler) (T, error)"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	in := ft.In(0)
	if in != reflect.TypeOf(new(http.Handler)).Elem() {
		panic(expected)
	}
	var outType reflect.Type
	var filter func([]reflect.Value) *reflect.Value
	if ft.NumOut() == 1 {
		// func(http.Handler) *T
		outType = ft.Out(0)
		if outType.Kind() != reflect.Ptr {
			panic(expected)
		}
		outType = outType.Elem()
		filter = func(values []reflect.Value) *reflect.Value {
			if values[0].IsNil() {
				return nil
			}
			val := values[0].Elem()
			return &val
		}
	} else if ft.NumOut() == 2 {
		outType = ft.Out(0)
		checker := ft.Out(1)
		if checker == reflect.TypeOf(true) {
			// func(http.Handler) (T, bool)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].Interface().(bool) {
					return &values[0]
				}
				return nil
			}
		} else if checker.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
			// func(http.Handler) (T, error)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].IsNil() {
					return &values[0]
				}
				return nil
			}
		} else {
			panic(expected)
		}
	} else {
		panic(expected)
	}

	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, s.Len())
	s.ForEach(func(item http.Handler) {
		ret := fVal.Call([]reflect.Value{reflect.ValueOf(item)})
		if val := filter(ret); val != nil {
			result = reflect.Append(result, *val)
		}
	})
	return result.Interface()
}

func (s *hSlice) DoUntil(f func(http.Handler) bool) int {
	for idx, item := range s.elements {
		if f(item) {
			return idx
		}
	}
	return -1
}

func (s *hSlice) DoWhile(f func(http.Handler) bool) int {
	for idx, item := range s.elements {
		if !f(item) {
			return idx
		}
	}
	return -1
}

func (s *hSlice) DoUntilError(f func(http.Handler) error) error {
	for _, item := range s.elements {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (s *hSlice) All(f func(http.Handler) bool) bool {
	for _, item := range s.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (s *hSlice) Any(f func(http.Handler) bool) bool {
	for _, item := range s.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (s *hSlice) Reduce(f func(http.Handler, http.Handler) http.Handler) http.Handler {
	if s.IsEmpty() {
		var defaultVal http.Handler
		return defaultVal
	}
	ret := s.elements[0]
	for _, item := range s.elements[1:] {
		ret = f(ret, item)
	}
	return ret
}

func (s *hSlice) Fold(init http.Handler, f func(http.Handler, http.Handler) http.Handler) http.Handler {
	if s.IsEmpty() {
		return init
	}
	for _, item := range s.elements {
		init = f(init, item)
	}
	return init
}

func (s *hSlice) String() string {
	return fmt.Sprint(s.elements)
}

func (s hSlice) MarshalJSON() ([]byte, error) {
	return json.Marshal(s.elements)
}

func (s *hSlice) UnmarshalJSON(b []byte) error {
	return json.Unmarshal(b, &s.elements)
}

type PSet struct {
	elements map[plugin.Plugin]struct{}
}

func NewPSet(capacity int) *PSet {
	set := new(PSet)
	if capacity > 0 {
		set.elements = make(map[plugin.Plugin]struct{}, capacity)
	} else {
		set.elements = make(map[plugin.Plugin]struct{})
	}
	return set
}

func NewPSetFromSlice(items []plugin.Plugin) *PSet {
	set := NewPSet(len(items))
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func (set *PSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *PSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *PSet) ToSlice() []plugin.Plugin {
	if set == nil {
		return nil
	}
	s := make([]plugin.Plugin, 0, set.Len())
	set.ForEach(func(item plugin.Plugin) {
		s = append(s, item)
	})
	return s
}

func (set *PSet) Append(keys ...plugin.Plugin) {
	for _, key := range keys {
		set.elements[key] = struct{}{}
	}
}

func (set *PSet) Clear() {
	set.elements = make(map[plugin.Plugin]struct{})
}

func (set *PSet) Clone() *PSet {
	cloned := NewPSet(set.Len())
	for item := range set.elements {
		cloned.elements[item] = struct{}{}
	}
	return cloned
}

func (set *PSet) Difference(another *PSet) *PSet {
	difference := NewPSet(0)
	set.ForEach(func(item plugin.Plugin) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *PSet) Equal(another *PSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *PSet) Intersect(another *PSet) *PSet {
	intersection := NewPSet(0)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *PSet) Union(another *PSet) *PSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *PSet) InPlaceUnion(another *PSet) {
	another.ForEach(func(item plugin.Plugin) {
		set.Append(item)
	})
}

func (set *PSet) IsProperSubsetOf(another *PSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *PSet) IsProperSupersetOf(another *PSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *PSet) IsSubsetOf(another *PSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *PSet) IsSupersetOf(another *PSet) bool {
	return another.IsSubsetOf(set)
}

func (set *PSet) ForEach(f func(plugin.Plugin)) {
	if set.IsEmpty() {
		return
	}
	for item := range set.elements {
		f(item)
	}
}

func (set *PSet) Filter(f func(plugin.Plugin) bool) *PSet {
	result := NewPSet(0)
	set.ForEach(func(item plugin.Plugin) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *PSet) Remove(key plugin.Plugin) {
	delete(set.elements, key)
}

func (set *PSet) Contains(key plugin.Plugin) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *PSet) ContainsAny(keys ...plugin.Plugin) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *PSet) ContainsAll(keys ...plugin.Plugin) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *PSet) DoUntilError(f func(plugin.Plugin) error) error {
	for item := range set.elements {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *PSet) All(f func(plugin.Plugin) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *PSet) Any(f func(plugin.Plugin) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *PSet) FindBy(f func(plugin.Plugin) bool) *plugin.Plugin {
	for item := range set.elements {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *PSet) CountBy(f func(plugin.Plugin) bool) int {
	count := 0
	set.ForEach(func(item plugin.Plugin) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *PSet) GroupByBool(f func(plugin.Plugin) bool) (trueGroup *PSet, falseGroup *PSet) {
	trueGroup, falseGroup = NewPSet(0), NewPSet(0)
	set.ForEach(func(item plugin.Plugin) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *PSet) GroupByStr(f func(plugin.Plugin) string) map[string]*PSet {
	groups := make(map[string]*PSet)
	set.ForEach(func(item plugin.Plugin) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewPSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *PSet) GroupByInt(f func(plugin.Plugin) int) map[int]*PSet {
	groups := make(map[int]*PSet)
	set.ForEach(func(item plugin.Plugin) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewPSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *PSet) GroupBy(f func(plugin.Plugin) interface{}) map[interface{}]*PSet {
	groups := make(map[interface{}]*PSet)
	set.ForEach(func(item plugin.Plugin) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewPSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

// f: func(plugin.Plugin) T
// return: []T
func (set *PSet) Map(f interface{}) interface{} {
	expected := "f should be func(plugin.Plugin)T"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	elemType := reflect.TypeOf(new(plugin.Plugin)).Elem()
	if ft.In(0) != elemType {
		panic(expected)
	}
	if ft.NumOut() != 1 {
		panic(expected)
	}
	outType := ft.Out(0)
	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item plugin.Plugin) {
		result = reflect.Append(result, fVal.Call([]reflect.Value{reflect.ValueOf(item)})[0])
	})
	return result.Interface()
}

// f: func(plugin.Plugin) *T
//    func(plugin.Plugin) (T, bool)
//    func(plugin.Plugin) (T, error)
// return: []T
func (set *PSet) FilterMap(f interface{}) interface{} {
	expected := "f should be func(plugin.Plugin) *T / func(plugin.Plugin) (T, bool) / func(plugin.Plugin) (T, error)"
	ft := reflect.TypeOf(f)
	fVal := reflect.ValueOf(f)
	if ft.Kind() != reflect.Func {
		panic(expected)
	}
	if ft.NumIn() != 1 {
		panic(expected)
	}
	in := ft.In(0)
	if in != reflect.TypeOf(new(plugin.Plugin)).Elem() {
		panic(expected)
	}
	var outType reflect.Type
	var filter func([]reflect.Value) *reflect.Value
	if ft.NumOut() == 1 {
		// func(plugin.Plugin) *T
		outType = ft.Out(0)
		if outType.Kind() != reflect.Ptr {
			panic(expected)
		}
		outType = outType.Elem()
		filter = func(values []reflect.Value) *reflect.Value {
			if values[0].IsNil() {
				return nil
			}
			val := values[0].Elem()
			return &val
		}
	} else if ft.NumOut() == 2 {
		outType = ft.Out(0)
		checker := ft.Out(1)
		if checker == reflect.TypeOf(true) {
			// func(plugin.Plugin) (T, bool)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].Interface().(bool) {
					return &values[0]
				}
				return nil
			}
		} else if checker.Implements(reflect.TypeOf((*error)(nil)).Elem()) {
			// func(plugin.Plugin) (T, error)
			filter = func(values []reflect.Value) *reflect.Value {
				if values[1].IsNil() {
					return &values[0]
				}
				return nil
			}
		} else {
			panic(expected)
		}
	} else {
		panic(expected)
	}

	result := reflect.MakeSlice(reflect.SliceOf(outType), 0, set.Len())
	set.ForEach(func(item plugin.Plugin) {
		ret := fVal.Call([]reflect.Value{reflect.ValueOf(item)})
		if val := filter(ret); val != nil {
			result = reflect.Append(result, *val)
		}
	})
	return result.Interface()
}

func (set *PSet) Reduce(f func(plugin.Plugin, plugin.Plugin) plugin.Plugin) plugin.Plugin {
	if set.IsEmpty() {
		var defaultVal plugin.Plugin
		return defaultVal
	}
	var ret plugin.Plugin
	first := true
	for item := range set.elements {
		if first {
			ret = item
			first = false
			continue
		}
		ret = f(ret, item)
	}
	return ret
}

func (set *PSet) Fold(init plugin.Plugin, f func(plugin.Plugin, plugin.Plugin) plugin.Plugin) plugin.Plugin {
	if set.IsEmpty() {
		return init
	}
	for item := range set.elements {
		init = f(init, item)
	}
	return init
}

func (set *PSet) String() string {
	return fmt.Sprint(set.ToSlice())
}

func (set PSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *PSet) UnmarshalJSON(b []byte) error {
	s := make([]plugin.Plugin, 0)
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*set = *NewPSetFromSlice(s)
	return nil
}
