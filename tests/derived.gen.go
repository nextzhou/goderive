// Code generated by https://github.com/nextzhou/goderive. DO NOT EDIT.

package tests

import (
	"encoding/json"
	"fmt"
	"net/http"
	"sort"
	t "time"
)

type aSet struct {
	elements map[A]struct{}
}

func newASet(capacity int) *aSet {
	set := new(aSet)
	if capacity > 0 {
		set.elements = make(map[A]struct{}, capacity)
	} else {
		set.elements = make(map[A]struct{})
	}
	return set
}

func newASetFromSlice(items []A) *aSet {
	set := newASet(len(items))
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func (set *aSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *aSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *aSet) ToSlice() []A {
	if set == nil {
		return nil
	}
	s := make([]A, 0, set.Len())
	set.ForEach(func(item A) {
		s = append(s, item)
	})
	return s
}

func (set *aSet) Append(keys ...A) {
	for _, key := range keys {
		set.elements[key] = struct{}{}
	}
}

func (set *aSet) Clear() {
	set.elements = make(map[A]struct{})
}

func (set *aSet) Clone() *aSet {
	cloned := newASet(set.Len())
	for item := range set.elements {
		cloned.elements[item] = struct{}{}
	}
	return cloned
}

func (set *aSet) Difference(another *aSet) *aSet {
	difference := newASet(0)
	set.ForEach(func(item A) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *aSet) Equal(another *aSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *aSet) Intersect(another *aSet) *aSet {
	intersection := newASet(0)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *aSet) Union(another *aSet) *aSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *aSet) InPlaceUnion(another *aSet) {
	another.ForEach(func(item A) {
		set.Append(item)
	})
}

func (set *aSet) IsProperSubsetOf(another *aSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *aSet) IsProperSupersetOf(another *aSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *aSet) IsSubsetOf(another *aSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *aSet) IsSupersetOf(another *aSet) bool {
	return another.IsSubsetOf(set)
}

func (set *aSet) ForEach(f func(A)) {
	if set.IsEmpty() {
		return
	}
	for item := range set.elements {
		f(item)
	}
}

func (set *aSet) Filter(f func(A) bool) *aSet {
	result := newASet(0)
	set.ForEach(func(item A) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *aSet) Remove(key A) {
	delete(set.elements, key)
}

func (set *aSet) Contains(key A) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *aSet) ContainsAny(keys ...A) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *aSet) ContainsAll(keys ...A) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *aSet) DoUntilError(f func(A) error) error {
	for item := range set.elements {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *aSet) All(f func(A) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *aSet) Any(f func(A) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *aSet) FindBy(f func(A) bool) *A {
	for item := range set.elements {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *aSet) CountBy(f func(A) bool) int {
	count := 0
	set.ForEach(func(item A) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *aSet) GroupByBool(f func(A) bool) (trueGroup *aSet, falseGroup *aSet) {
	trueGroup, falseGroup = newASet(0), newASet(0)
	set.ForEach(func(item A) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *aSet) GroupByStr(f func(A) string) map[string]*aSet {
	groups := make(map[string]*aSet)
	set.ForEach(func(item A) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newASet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *aSet) GroupByInt(f func(A) int) map[int]*aSet {
	groups := make(map[int]*aSet)
	set.ForEach(func(item A) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newASet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *aSet) GroupBy(f func(A) interface{}) map[interface{}]*aSet {
	groups := make(map[interface{}]*aSet)
	set.ForEach(func(item A) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newASet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *aSet) String() string {
	return fmt.Sprint(set.ToSlice())
}

func (set *aSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *aSet) UnmarshalJSON(b []byte) error {
	s := make([]A, 0)
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*set = *newASetFromSlice(s)
	return nil
}

type IntSet struct {
	elements map[int]struct{}
}

func NewIntSet(capacity int) *IntSet {
	set := new(IntSet)
	if capacity > 0 {
		set.elements = make(map[int]struct{}, capacity)
	} else {
		set.elements = make(map[int]struct{})
	}
	return set
}

func NewIntSetFromSlice(items []int) *IntSet {
	set := NewIntSet(len(items))
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func (set *IntSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *IntSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *IntSet) ToSlice() []int {
	if set == nil {
		return nil
	}
	s := make([]int, 0, set.Len())
	set.ForEach(func(item int) {
		s = append(s, item)
	})
	return s
}

func (set *IntSet) Append(keys ...int) {
	for _, key := range keys {
		set.elements[key] = struct{}{}
	}
}

func (set *IntSet) Clear() {
	set.elements = make(map[int]struct{})
}

func (set *IntSet) Clone() *IntSet {
	cloned := NewIntSet(set.Len())
	for item := range set.elements {
		cloned.elements[item] = struct{}{}
	}
	return cloned
}

func (set *IntSet) Difference(another *IntSet) *IntSet {
	difference := NewIntSet(0)
	set.ForEach(func(item int) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *IntSet) Equal(another *IntSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *IntSet) Intersect(another *IntSet) *IntSet {
	intersection := NewIntSet(0)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *IntSet) Union(another *IntSet) *IntSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *IntSet) InPlaceUnion(another *IntSet) {
	another.ForEach(func(item int) {
		set.Append(item)
	})
}

func (set *IntSet) IsProperSubsetOf(another *IntSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *IntSet) IsProperSupersetOf(another *IntSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *IntSet) IsSubsetOf(another *IntSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *IntSet) IsSupersetOf(another *IntSet) bool {
	return another.IsSubsetOf(set)
}

func (set *IntSet) ForEach(f func(int)) {
	if set.IsEmpty() {
		return
	}
	for item := range set.elements {
		f(item)
	}
}

func (set *IntSet) Filter(f func(int) bool) *IntSet {
	result := NewIntSet(0)
	set.ForEach(func(item int) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *IntSet) Remove(key int) {
	delete(set.elements, key)
}

func (set *IntSet) Contains(key int) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *IntSet) ContainsAny(keys ...int) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *IntSet) ContainsAll(keys ...int) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *IntSet) DoUntilError(f func(int) error) error {
	for item := range set.elements {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *IntSet) All(f func(int) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *IntSet) Any(f func(int) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *IntSet) FindBy(f func(int) bool) *int {
	for item := range set.elements {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *IntSet) CountBy(f func(int) bool) int {
	count := 0
	set.ForEach(func(item int) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *IntSet) GroupByBool(f func(int) bool) (trueGroup *IntSet, falseGroup *IntSet) {
	trueGroup, falseGroup = NewIntSet(0), NewIntSet(0)
	set.ForEach(func(item int) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *IntSet) GroupByStr(f func(int) string) map[string]*IntSet {
	groups := make(map[string]*IntSet)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewIntSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *IntSet) GroupByInt(f func(int) int) map[int]*IntSet {
	groups := make(map[int]*IntSet)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewIntSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *IntSet) GroupBy(f func(int) interface{}) map[interface{}]*IntSet {
	groups := make(map[interface{}]*IntSet)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewIntSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *IntSet) String() string {
	return fmt.Sprint(set.ToSlice())
}

func (set *IntSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *IntSet) UnmarshalJSON(b []byte) error {
	s := make([]int, 0)
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*set = *NewIntSetFromSlice(s)
	return nil
}

type intOrderSet struct {
	elements        map[int]uint32
	elementSequence []int
}

func newIntOrderSet(capacity int) *intOrderSet {
	set := new(intOrderSet)
	if capacity > 0 {
		set.elements = make(map[int]uint32, capacity)
		set.elementSequence = make([]int, 0, capacity)
	} else {
		set.elements = make(map[int]uint32)
	}
	return set
}

func newIntOrderSetFromSlice(items []int) *intOrderSet {
	set := newIntOrderSet(len(items))
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func (set *intOrderSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *intOrderSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *intOrderSet) ToSlice() []int {
	if set == nil {
		return nil
	}
	s := make([]int, set.Len())
	copy(s, set.elementSequence)
	return s
}

// NOTICE: efficient but unsafe
func (set *intOrderSet) ToSliceRef() []int {
	return set.elementSequence
}

func (set *intOrderSet) Append(keys ...int) {
	for _, key := range keys {
		if _, ok := set.elements[key]; !ok {
			set.elements[key] = uint32(len(set.elementSequence))
			set.elementSequence = append(set.elementSequence, key)
		}
	}
}

func (set *intOrderSet) Clear() {
	set.elements = make(map[int]uint32)
	set.elementSequence = set.elementSequence[:0]
}

func (set *intOrderSet) Clone() *intOrderSet {
	cloned := newIntOrderSet(set.Len())
	for idx, item := range set.elementSequence {
		cloned.elements[item] = uint32(idx)
		cloned.elementSequence = append(cloned.elementSequence, item)
	}
	return cloned
}

func (set *intOrderSet) Difference(another *intOrderSet) *intOrderSet {
	difference := newIntOrderSet(0)
	set.ForEach(func(item int) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *intOrderSet) Equal(another *intOrderSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	return set.ContainsAll(another.elementSequence...)
}

// TODO keep order
func (set *intOrderSet) Intersect(another *intOrderSet) *intOrderSet {
	intersection := newIntOrderSet(0)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *intOrderSet) Union(another *intOrderSet) *intOrderSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *intOrderSet) InPlaceUnion(another *intOrderSet) {
	another.ForEach(func(item int) {
		set.Append(item)
	})
}

func (set *intOrderSet) IsProperSubsetOf(another *intOrderSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *intOrderSet) IsProperSupersetOf(another *intOrderSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *intOrderSet) IsSubsetOf(another *intOrderSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *intOrderSet) IsSupersetOf(another *intOrderSet) bool {
	return another.IsSubsetOf(set)
}

func (set *intOrderSet) ForEach(f func(int)) {
	if set.IsEmpty() {
		return
	}
	for _, item := range set.elementSequence {
		f(item)
	}
}

func (set *intOrderSet) Filter(f func(int) bool) *intOrderSet {
	result := newIntOrderSet(0)
	set.ForEach(func(item int) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *intOrderSet) Remove(key int) {
	if idx, ok := set.elements[key]; ok {
		l := set.Len()
		delete(set.elements, key)
		for ; idx < uint32(l-1); idx++ {
			item := set.elementSequence[idx+1]
			set.elementSequence[idx] = item
			set.elements[item] = idx
		}
		set.elementSequence = set.elementSequence[:l-1]
	}
}

func (set *intOrderSet) Contains(key int) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *intOrderSet) ContainsAny(keys ...int) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *intOrderSet) ContainsAll(keys ...int) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *intOrderSet) DoUntil(f func(int) bool) int {
	for idx, item := range set.elementSequence {
		if f(item) {
			return idx
		}
	}
	return -1
}

func (set *intOrderSet) DoWhile(f func(int) bool) int {
	for idx, item := range set.elementSequence {
		if !f(item) {
			return idx
		}
	}
	return -1
}

func (set *intOrderSet) DoUntilError(f func(int) error) error {
	for _, item := range set.elementSequence {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *intOrderSet) All(f func(int) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *intOrderSet) Any(f func(int) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *intOrderSet) FindBy(f func(int) bool) *int {
	for _, item := range set.elementSequence {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *intOrderSet) FindLastBy(f func(int) bool) *int {
	for i := set.Len() - 1; i >= 0; i-- {
		if item := set.elementSequence[i]; f(item) {
			return &item
		}
	}
	return nil
}

func (set *intOrderSet) CountBy(f func(int) bool) int {
	count := 0
	set.ForEach(func(item int) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *intOrderSet) GroupByBool(f func(int) bool) (trueGroup *intOrderSet, falseGroup *intOrderSet) {
	trueGroup, falseGroup = newIntOrderSet(0), newIntOrderSet(0)
	set.ForEach(func(item int) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *intOrderSet) GroupByStr(f func(int) string) map[string]*intOrderSet {
	groups := make(map[string]*intOrderSet)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newIntOrderSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *intOrderSet) GroupByInt(f func(int) int) map[int]*intOrderSet {
	groups := make(map[int]*intOrderSet)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newIntOrderSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *intOrderSet) GroupBy(f func(int) interface{}) map[interface{}]*intOrderSet {
	groups := make(map[interface{}]*intOrderSet)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newIntOrderSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *intOrderSet) String() string {
	return fmt.Sprint(set.elementSequence)
}

func (set *intOrderSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *intOrderSet) UnmarshalJSON(b []byte) error {
	s := make([]int, 0)
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*set = *newIntOrderSetFromSlice(s)
	return nil
}

type Int3Set struct {
	cmp             func(i, j int) bool
	elements        map[int]uint32
	elementSequence []int
}

func NewInt3Set(capacity int, cmp func(i, j int) bool) *Int3Set {
	set := new(Int3Set)
	if capacity > 0 {
		set.elements = make(map[int]uint32, capacity)
		set.elementSequence = make([]int, 0, capacity)
	} else {
		set.elements = make(map[int]uint32)
	}
	set.cmp = cmp
	return set
}

func NewInt3SetFromSlice(items []int, cmp func(i, j int) bool) *Int3Set {
	set := NewInt3Set(len(items), cmp)
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func NewAscendingInt3Set(capacity int) *Int3Set {
	return NewInt3Set(capacity, func(i, j int) bool { return i < j })
}

func NewDescendingInt3Set(capacity int) *Int3Set {
	return NewInt3Set(capacity, func(i, j int) bool { return i > j })
}

func NewAscendingInt3SetFromSlice(items []int) *Int3Set {
	return NewInt3SetFromSlice(items, func(i, j int) bool { return i < j })
}

func NewDescendingInt3SetFromSlice(items []int) *Int3Set {
	return NewInt3SetFromSlice(items, func(i, j int) bool { return i > j })
}

func (set *Int3Set) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *Int3Set) IsEmpty() bool {
	return set.Len() == 0
}

func (set *Int3Set) ToSlice() []int {
	if set == nil {
		return nil
	}
	s := make([]int, set.Len())
	copy(s, set.elementSequence)
	return s
}

// NOTICE: efficient but unsafe
func (set *Int3Set) ToSliceRef() []int {
	return set.elementSequence
}

func (set *Int3Set) Append(keys ...int) {
	for _, key := range keys {
		if _, ok := set.elements[key]; !ok {
			idx := sort.Search(len(set.elementSequence), func(i int) bool {
				return set.cmp(key, set.elementSequence[i])
			})
			l := len(set.elementSequence)
			set.elementSequence = append(set.elementSequence, key)
			for i := l; i > idx; i-- {
				set.elements[set.elementSequence[i]] = uint32(i + 1)
				set.elementSequence[i] = set.elementSequence[i-1]
			}
			set.elements[set.elementSequence[idx]] = uint32(idx + 1)
			set.elementSequence[idx] = key
			set.elements[key] = uint32(idx)
		}
	}
}

func (set *Int3Set) Clear() {
	set.elements = make(map[int]uint32)
	set.elementSequence = set.elementSequence[:0]
}

func (set *Int3Set) Clone() *Int3Set {
	cloned := NewInt3Set(set.Len(), set.cmp)
	for idx, item := range set.elementSequence {
		cloned.elements[item] = uint32(idx)
		cloned.elementSequence = append(cloned.elementSequence, item)
	}
	return cloned
}

func (set *Int3Set) Difference(another *Int3Set) *Int3Set {
	difference := NewInt3Set(0, set.cmp)
	set.ForEach(func(item int) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *Int3Set) Equal(another *Int3Set) bool {
	if set.Len() != another.Len() {
		return false
	}
	return set.ContainsAll(another.elementSequence...)
}

func (set *Int3Set) Intersect(another *Int3Set) *Int3Set {
	intersection := NewInt3Set(0, set.cmp)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *Int3Set) Union(another *Int3Set) *Int3Set {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *Int3Set) InPlaceUnion(another *Int3Set) {
	another.ForEach(func(item int) {
		set.Append(item)
	})
}

func (set *Int3Set) IsProperSubsetOf(another *Int3Set) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *Int3Set) IsProperSupersetOf(another *Int3Set) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *Int3Set) IsSubsetOf(another *Int3Set) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *Int3Set) IsSupersetOf(another *Int3Set) bool {
	return another.IsSubsetOf(set)
}

func (set *Int3Set) ForEach(f func(int)) {
	if set.IsEmpty() {
		return
	}
	for _, item := range set.elementSequence {
		f(item)
	}
}

func (set *Int3Set) Filter(f func(int) bool) *Int3Set {
	result := NewInt3Set(0, set.cmp)
	set.ForEach(func(item int) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *Int3Set) Remove(key int) {
	if idx, ok := set.elements[key]; ok {
		l := set.Len()
		delete(set.elements, key)
		for ; idx < uint32(l-1); idx++ {
			item := set.elementSequence[idx+1]
			set.elementSequence[idx] = item
			set.elements[item] = idx
		}
		set.elementSequence = set.elementSequence[:l-1]
	}
}

func (set *Int3Set) Contains(key int) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *Int3Set) ContainsAny(keys ...int) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *Int3Set) ContainsAll(keys ...int) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *Int3Set) DoUntil(f func(int) bool) int {
	for idx, item := range set.elementSequence {
		if f(item) {
			return idx
		}
	}
	return -1
}

func (set *Int3Set) DoWhile(f func(int) bool) int {
	for idx, item := range set.elementSequence {
		if !f(item) {
			return idx
		}
	}
	return -1
}

func (set *Int3Set) DoUntilError(f func(int) error) error {
	for _, item := range set.elementSequence {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *Int3Set) All(f func(int) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *Int3Set) Any(f func(int) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *Int3Set) FindBy(f func(int) bool) *int {
	for _, item := range set.elementSequence {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *Int3Set) FindLastBy(f func(int) bool) *int {
	for i := set.Len() - 1; i >= 0; i-- {
		if item := set.elementSequence[i]; f(item) {
			return &item
		}
	}
	return nil
}

func (set *Int3Set) CountBy(f func(int) bool) int {
	count := 0
	set.ForEach(func(item int) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *Int3Set) GroupByBool(f func(int) bool) (trueGroup *Int3Set, falseGroup *Int3Set) {
	trueGroup, falseGroup = NewInt3Set(0, set.cmp), NewInt3Set(0, set.cmp)
	set.ForEach(func(item int) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *Int3Set) GroupByStr(f func(int) string) map[string]*Int3Set {
	groups := make(map[string]*Int3Set)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewInt3Set(0, set.cmp)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *Int3Set) GroupByInt(f func(int) int) map[int]*Int3Set {
	groups := make(map[int]*Int3Set)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewInt3Set(0, set.cmp)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *Int3Set) GroupBy(f func(int) interface{}) map[interface{}]*Int3Set {
	groups := make(map[interface{}]*Int3Set)
	set.ForEach(func(item int) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewInt3Set(0, set.cmp)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *Int3Set) String() string {
	return fmt.Sprint(set.elementSequence)
}

func (set *Int3Set) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *Int3Set) UnmarshalJSON(b []byte) error {
	return fmt.Errorf("unsupported")
}

type SSet struct {
	cmp             func(i, j string) bool
	elements        map[string]uint32
	elementSequence []string
}

func NewSSet(capacity int, cmp func(i, j string) bool) *SSet {
	set := new(SSet)
	if capacity > 0 {
		set.elements = make(map[string]uint32, capacity)
		set.elementSequence = make([]string, 0, capacity)
	} else {
		set.elements = make(map[string]uint32)
	}
	set.cmp = cmp
	return set
}

func NewSSetFromSlice(items []string, cmp func(i, j string) bool) *SSet {
	set := NewSSet(len(items), cmp)
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func NewAscendingSSet(capacity int) *SSet {
	return NewSSet(capacity, func(i, j string) bool { return i < j })
}

func NewDescendingSSet(capacity int) *SSet {
	return NewSSet(capacity, func(i, j string) bool { return i > j })
}

func NewAscendingSSetFromSlice(items []string) *SSet {
	return NewSSetFromSlice(items, func(i, j string) bool { return i < j })
}

func NewDescendingSSetFromSlice(items []string) *SSet {
	return NewSSetFromSlice(items, func(i, j string) bool { return i > j })
}

func (set *SSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *SSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *SSet) ToSlice() []string {
	if set == nil {
		return nil
	}
	s := make([]string, set.Len())
	copy(s, set.elementSequence)
	return s
}

// NOTICE: efficient but unsafe
func (set *SSet) ToSliceRef() []string {
	return set.elementSequence
}

func (set *SSet) Append(keys ...string) {
	for _, key := range keys {
		if _, ok := set.elements[key]; !ok {
			idx := sort.Search(len(set.elementSequence), func(i int) bool {
				return set.cmp(key, set.elementSequence[i])
			})
			l := len(set.elementSequence)
			set.elementSequence = append(set.elementSequence, key)
			for i := l; i > idx; i-- {
				set.elements[set.elementSequence[i]] = uint32(i + 1)
				set.elementSequence[i] = set.elementSequence[i-1]
			}
			set.elements[set.elementSequence[idx]] = uint32(idx + 1)
			set.elementSequence[idx] = key
			set.elements[key] = uint32(idx)
		}
	}
}

func (set *SSet) Clear() {
	set.elements = make(map[string]uint32)
	set.elementSequence = set.elementSequence[:0]
}

func (set *SSet) Clone() *SSet {
	cloned := NewSSet(set.Len(), set.cmp)
	for idx, item := range set.elementSequence {
		cloned.elements[item] = uint32(idx)
		cloned.elementSequence = append(cloned.elementSequence, item)
	}
	return cloned
}

func (set *SSet) Difference(another *SSet) *SSet {
	difference := NewSSet(0, set.cmp)
	set.ForEach(func(item string) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *SSet) Equal(another *SSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	return set.ContainsAll(another.elementSequence...)
}

func (set *SSet) Intersect(another *SSet) *SSet {
	intersection := NewSSet(0, set.cmp)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *SSet) Union(another *SSet) *SSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *SSet) InPlaceUnion(another *SSet) {
	another.ForEach(func(item string) {
		set.Append(item)
	})
}

func (set *SSet) IsProperSubsetOf(another *SSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *SSet) IsProperSupersetOf(another *SSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *SSet) IsSubsetOf(another *SSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *SSet) IsSupersetOf(another *SSet) bool {
	return another.IsSubsetOf(set)
}

func (set *SSet) ForEach(f func(string)) {
	if set.IsEmpty() {
		return
	}
	for _, item := range set.elementSequence {
		f(item)
	}
}

func (set *SSet) Filter(f func(string) bool) *SSet {
	result := NewSSet(0, set.cmp)
	set.ForEach(func(item string) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *SSet) Remove(key string) {
	if idx, ok := set.elements[key]; ok {
		l := set.Len()
		delete(set.elements, key)
		for ; idx < uint32(l-1); idx++ {
			item := set.elementSequence[idx+1]
			set.elementSequence[idx] = item
			set.elements[item] = idx
		}
		set.elementSequence = set.elementSequence[:l-1]
	}
}

func (set *SSet) Contains(key string) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *SSet) ContainsAny(keys ...string) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *SSet) ContainsAll(keys ...string) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *SSet) DoUntil(f func(string) bool) int {
	for idx, item := range set.elementSequence {
		if f(item) {
			return idx
		}
	}
	return -1
}

func (set *SSet) DoWhile(f func(string) bool) int {
	for idx, item := range set.elementSequence {
		if !f(item) {
			return idx
		}
	}
	return -1
}

func (set *SSet) DoUntilError(f func(string) error) error {
	for _, item := range set.elementSequence {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *SSet) All(f func(string) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *SSet) Any(f func(string) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *SSet) FindBy(f func(string) bool) *string {
	for _, item := range set.elementSequence {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *SSet) FindLastBy(f func(string) bool) *string {
	for i := set.Len() - 1; i >= 0; i-- {
		if item := set.elementSequence[i]; f(item) {
			return &item
		}
	}
	return nil
}

func (set *SSet) CountBy(f func(string) bool) int {
	count := 0
	set.ForEach(func(item string) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *SSet) GroupByBool(f func(string) bool) (trueGroup *SSet, falseGroup *SSet) {
	trueGroup, falseGroup = NewSSet(0, set.cmp), NewSSet(0, set.cmp)
	set.ForEach(func(item string) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *SSet) GroupByStr(f func(string) string) map[string]*SSet {
	groups := make(map[string]*SSet)
	set.ForEach(func(item string) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewSSet(0, set.cmp)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *SSet) GroupByInt(f func(string) int) map[int]*SSet {
	groups := make(map[int]*SSet)
	set.ForEach(func(item string) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewSSet(0, set.cmp)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *SSet) GroupBy(f func(string) interface{}) map[interface{}]*SSet {
	groups := make(map[interface{}]*SSet)
	set.ForEach(func(item string) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewSSet(0, set.cmp)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *SSet) String() string {
	return fmt.Sprint(set.elementSequence)
}

func (set *SSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *SSet) UnmarshalJSON(b []byte) error {
	return fmt.Errorf("unsupported")
}

type TSet struct {
	elements map[t.Time]struct{}
}

func NewTSet(capacity int) *TSet {
	set := new(TSet)
	if capacity > 0 {
		set.elements = make(map[t.Time]struct{}, capacity)
	} else {
		set.elements = make(map[t.Time]struct{})
	}
	return set
}

func NewTSetFromSlice(items []t.Time) *TSet {
	set := NewTSet(len(items))
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func (set *TSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *TSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *TSet) ToSlice() []t.Time {
	if set == nil {
		return nil
	}
	s := make([]t.Time, 0, set.Len())
	set.ForEach(func(item t.Time) {
		s = append(s, item)
	})
	return s
}

func (set *TSet) Append(keys ...t.Time) {
	for _, key := range keys {
		set.elements[key] = struct{}{}
	}
}

func (set *TSet) Clear() {
	set.elements = make(map[t.Time]struct{})
}

func (set *TSet) Clone() *TSet {
	cloned := NewTSet(set.Len())
	for item := range set.elements {
		cloned.elements[item] = struct{}{}
	}
	return cloned
}

func (set *TSet) Difference(another *TSet) *TSet {
	difference := NewTSet(0)
	set.ForEach(func(item t.Time) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *TSet) Equal(another *TSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *TSet) Intersect(another *TSet) *TSet {
	intersection := NewTSet(0)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *TSet) Union(another *TSet) *TSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *TSet) InPlaceUnion(another *TSet) {
	another.ForEach(func(item t.Time) {
		set.Append(item)
	})
}

func (set *TSet) IsProperSubsetOf(another *TSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *TSet) IsProperSupersetOf(another *TSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *TSet) IsSubsetOf(another *TSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *TSet) IsSupersetOf(another *TSet) bool {
	return another.IsSubsetOf(set)
}

func (set *TSet) ForEach(f func(t.Time)) {
	if set.IsEmpty() {
		return
	}
	for item := range set.elements {
		f(item)
	}
}

func (set *TSet) Filter(f func(t.Time) bool) *TSet {
	result := NewTSet(0)
	set.ForEach(func(item t.Time) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *TSet) Remove(key t.Time) {
	delete(set.elements, key)
}

func (set *TSet) Contains(key t.Time) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *TSet) ContainsAny(keys ...t.Time) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *TSet) ContainsAll(keys ...t.Time) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *TSet) DoUntilError(f func(t.Time) error) error {
	for item := range set.elements {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *TSet) All(f func(t.Time) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *TSet) Any(f func(t.Time) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *TSet) FindBy(f func(t.Time) bool) *t.Time {
	for item := range set.elements {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *TSet) CountBy(f func(t.Time) bool) int {
	count := 0
	set.ForEach(func(item t.Time) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *TSet) GroupByBool(f func(t.Time) bool) (trueGroup *TSet, falseGroup *TSet) {
	trueGroup, falseGroup = NewTSet(0), NewTSet(0)
	set.ForEach(func(item t.Time) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *TSet) GroupByStr(f func(t.Time) string) map[string]*TSet {
	groups := make(map[string]*TSet)
	set.ForEach(func(item t.Time) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewTSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *TSet) GroupByInt(f func(t.Time) int) map[int]*TSet {
	groups := make(map[int]*TSet)
	set.ForEach(func(item t.Time) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewTSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *TSet) GroupBy(f func(t.Time) interface{}) map[interface{}]*TSet {
	groups := make(map[interface{}]*TSet)
	set.ForEach(func(item t.Time) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = NewTSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *TSet) String() string {
	return fmt.Sprint(set.ToSlice())
}

func (set *TSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *TSet) UnmarshalJSON(b []byte) error {
	s := make([]t.Time, 0)
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*set = *NewTSetFromSlice(s)
	return nil
}

type hSet struct {
	elements map[http.Handler]struct{}
}

func newHSet(capacity int) *hSet {
	set := new(hSet)
	if capacity > 0 {
		set.elements = make(map[http.Handler]struct{}, capacity)
	} else {
		set.elements = make(map[http.Handler]struct{})
	}
	return set
}

func newHSetFromSlice(items []http.Handler) *hSet {
	set := newHSet(len(items))
	for _, item := range items {
		set.Append(item)
	}
	return set
}

func (set *hSet) Len() int {
	if set == nil {
		return 0
	}
	return len(set.elements)
}

func (set *hSet) IsEmpty() bool {
	return set.Len() == 0
}

func (set *hSet) ToSlice() []http.Handler {
	if set == nil {
		return nil
	}
	s := make([]http.Handler, 0, set.Len())
	set.ForEach(func(item http.Handler) {
		s = append(s, item)
	})
	return s
}

func (set *hSet) Append(keys ...http.Handler) {
	for _, key := range keys {
		set.elements[key] = struct{}{}
	}
}

func (set *hSet) Clear() {
	set.elements = make(map[http.Handler]struct{})
}

func (set *hSet) Clone() *hSet {
	cloned := newHSet(set.Len())
	for item := range set.elements {
		cloned.elements[item] = struct{}{}
	}
	return cloned
}

func (set *hSet) Difference(another *hSet) *hSet {
	difference := newHSet(0)
	set.ForEach(func(item http.Handler) {
		if !another.Contains(item) {
			difference.Append(item)
		}
	})
	return difference
}

func (set *hSet) Equal(another *hSet) bool {
	if set.Len() != another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *hSet) Intersect(another *hSet) *hSet {
	intersection := newHSet(0)
	if set.Len() < another.Len() {
		for item := range set.elements {
			if another.Contains(item) {
				intersection.Append(item)
			}
		}
	} else {
		for item := range another.elements {
			if set.Contains(item) {
				intersection.Append(item)
			}
		}
	}
	return intersection
}

func (set *hSet) Union(another *hSet) *hSet {
	union := set.Clone()
	union.InPlaceUnion(another)
	return union
}

func (set *hSet) InPlaceUnion(another *hSet) {
	another.ForEach(func(item http.Handler) {
		set.Append(item)
	})
}

func (set *hSet) IsProperSubsetOf(another *hSet) bool {
	return !set.Equal(another) && set.IsSubsetOf(another)
}

func (set *hSet) IsProperSupersetOf(another *hSet) bool {
	return !set.Equal(another) && set.IsSupersetOf(another)
}

func (set *hSet) IsSubsetOf(another *hSet) bool {
	if set.Len() > another.Len() {
		return false
	}
	for item := range set.elements {
		if !another.Contains(item) {
			return false
		}
	}
	return true
}

func (set *hSet) IsSupersetOf(another *hSet) bool {
	return another.IsSubsetOf(set)
}

func (set *hSet) ForEach(f func(http.Handler)) {
	if set.IsEmpty() {
		return
	}
	for item := range set.elements {
		f(item)
	}
}

func (set *hSet) Filter(f func(http.Handler) bool) *hSet {
	result := newHSet(0)
	set.ForEach(func(item http.Handler) {
		if f(item) {
			result.Append(item)
		}
	})
	return result
}

func (set *hSet) Remove(key http.Handler) {
	delete(set.elements, key)
}

func (set *hSet) Contains(key http.Handler) bool {
	_, ok := set.elements[key]
	return ok
}

func (set *hSet) ContainsAny(keys ...http.Handler) bool {
	for _, key := range keys {
		if set.Contains(key) {
			return true
		}
	}
	return false
}

func (set *hSet) ContainsAll(keys ...http.Handler) bool {
	for _, key := range keys {
		if !set.Contains(key) {
			return false
		}
	}
	return true
}

func (set *hSet) DoUntilError(f func(http.Handler) error) error {
	for item := range set.elements {
		if err := f(item); err != nil {
			return err
		}
	}
	return nil
}

func (set *hSet) All(f func(http.Handler) bool) bool {
	for item := range set.elements {
		if !f(item) {
			return false
		}
	}
	return true
}

func (set *hSet) Any(f func(http.Handler) bool) bool {
	for item := range set.elements {
		if f(item) {
			return true
		}
	}
	return false
}

func (set *hSet) FindBy(f func(http.Handler) bool) *http.Handler {
	for item := range set.elements {
		if f(item) {
			return &item
		}
	}
	return nil
}

func (set *hSet) CountBy(f func(http.Handler) bool) int {
	count := 0
	set.ForEach(func(item http.Handler) {
		if f(item) {
			count++
		}
	})
	return count
}

func (set *hSet) GroupByBool(f func(http.Handler) bool) (trueGroup *hSet, falseGroup *hSet) {
	trueGroup, falseGroup = newHSet(0), newHSet(0)
	set.ForEach(func(item http.Handler) {
		if f(item) {
			trueGroup.Append(item)
		} else {
			falseGroup.Append(item)
		}
	})
	return trueGroup, falseGroup
}

func (set *hSet) GroupByStr(f func(http.Handler) string) map[string]*hSet {
	groups := make(map[string]*hSet)
	set.ForEach(func(item http.Handler) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newHSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *hSet) GroupByInt(f func(http.Handler) int) map[int]*hSet {
	groups := make(map[int]*hSet)
	set.ForEach(func(item http.Handler) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newHSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *hSet) GroupBy(f func(http.Handler) interface{}) map[interface{}]*hSet {
	groups := make(map[interface{}]*hSet)
	set.ForEach(func(item http.Handler) {
		key := f(item)
		group := groups[key]
		if group == nil {
			group = newHSet(0)
			groups[key] = group
		}
		group.Append(item)
	})
	return groups
}

func (set *hSet) String() string {
	return fmt.Sprint(set.ToSlice())
}

func (set *hSet) MarshalJSON() ([]byte, error) {
	return json.Marshal(set.ToSlice())
}

func (set *hSet) UnmarshalJSON(b []byte) error {
	s := make([]http.Handler, 0)
	err := json.Unmarshal(b, &s)
	if err != nil {
		return err
	}
	*set = *newHSetFromSlice(s)
	return nil
}
